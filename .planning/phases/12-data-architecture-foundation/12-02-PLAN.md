---
phase: 12-data-architecture-foundation
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - autonomo_dashboard.html
autonomous: true

must_haves:
  truths:
    - "Soft-deleted records are excluded from active queries"
    - "User can restore records within 30 days"
    - "Records older than 4 years are auto-purged on app load"
    - "All CRUD operations are queued for sync"
    - "Sync indicator shows pending change count"
  artifacts:
    - path: "autonomo_dashboard.html"
      provides: "DataManager with soft delete and sync queue"
      contains: "softDelete"
  key_links:
    - from: "DataManager.softDelete"
      to: "sync_queue table"
      via: "queueChange function"
      pattern: "queueChange\\("
    - from: "initializeDatabase"
      to: "autoPurgeOldRecords"
      via: "maintenance step"
      pattern: "autoPurgeOldRecords"
---

<objective>
Implement the soft delete system with 4-year retention policy and the sync queue infrastructure for offline-first operation.

Purpose: Spanish tax law requires 4-year retention of financial records. Soft delete ensures audit compliance while sync queue enables offline work that synchronizes later.

Output: DataManager module with soft delete, restore, auto-purge, and sync queue operations.
</objective>

<execution_context>
@/Users/christophercardoen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/christophercardoen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-data-architecture-foundation/12-CONTEXT.md
@.planning/phases/12-data-architecture-foundation/12-RESEARCH.md
@.planning/phases/12-data-architecture-foundation/12-01-SUMMARY.md
@autonomo_dashboard.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Soft Delete and Retention System</name>
  <files>autonomo_dashboard.html</files>
  <action>
Add the DataManager module after the auditFields helper (before initializeDatabase):

```javascript
// =====================================================
// Data Manager (Soft Delete & Retention)
// =====================================================

const DataManager = {
  // Tables that support soft delete (financial records)
  SOFT_DELETE_TABLES: ['invoices', 'expenses', 'receipts', 'clients', 'entities', 'projects'],

  // Retention period in years (Spanish tax audit statute of limitations)
  RETENTION_YEARS: 4,

  // Restore window in days
  RESTORE_WINDOW_DAYS: 30,

  /**
   * Soft delete a record (set deleted_at, queue for sync)
   * @param {string} tableName - Table to delete from
   * @param {number} id - Record ID
   * @returns {Promise<boolean>} Success status
   */
  async softDelete(tableName, id) {
    if (!this.SOFT_DELETE_TABLES.includes(tableName)) {
      throw new Error(`Table ${tableName} does not support soft delete`);
    }

    const record = await db[tableName].get(id);
    if (!record) {
      throw new Error(`Record not found: ${tableName}/${id}`);
    }

    if (record.deleted_at) {
      throw new Error('Record already deleted');
    }

    const now = new Date().toISOString();
    const changes = {
      deleted_at: now,
      ...auditFields(false)
    };

    await db[tableName].update(id, changes);
    await SyncQueue.queueChange(tableName, id, 'UPDATE', changes);

    console.log(`Soft deleted: ${tableName}/${id}`);
    return true;
  },

  /**
   * Restore a soft-deleted record (within 30-day window)
   * @param {string} tableName - Table to restore from
   * @param {number} id - Record ID
   * @returns {Promise<boolean>} Success status
   */
  async restore(tableName, id) {
    const record = await db[tableName].get(id);
    if (!record) {
      throw new Error(`Record not found: ${tableName}/${id}`);
    }

    if (!record.deleted_at) {
      throw new Error('Record is not deleted');
    }

    // Check restore window
    const deletedDate = new Date(record.deleted_at);
    const daysSinceDeleted = (Date.now() - deletedDate.getTime()) / (1000 * 60 * 60 * 24);

    if (daysSinceDeleted > this.RESTORE_WINDOW_DAYS) {
      throw new Error(`Cannot restore: Record deleted more than ${this.RESTORE_WINDOW_DAYS} days ago. ` +
        `Record will be retained for audit until ${this.RETENTION_YEARS}-year purge.`);
    }

    const changes = {
      deleted_at: null,
      ...auditFields(false)
    };

    await db[tableName].update(id, changes);
    await SyncQueue.queueChange(tableName, id, 'UPDATE', changes);

    console.log(`Restored: ${tableName}/${id}`);
    return true;
  },

  /**
   * Get active records (not deleted)
   * @param {string} tableName - Table to query
   * @param {number} entityId - Entity filter (optional)
   * @returns {Promise<Array>} Active records
   */
  async getActive(tableName, entityId = null) {
    let query = db[tableName];

    if (entityId && db[tableName].schema.indexes.some(i => i.name === '[entity_id+deleted_at]')) {
      // Use compound index if available
      return query.where('[entity_id+deleted_at]').equals([entityId, null]).toArray();
    }

    // Fallback to filter
    let results = await query.toArray();
    results = results.filter(r => r.deleted_at === null || r.deleted_at === undefined);

    if (entityId) {
      results = results.filter(r => r.entity_id === entityId);
    }

    return results;
  },

  /**
   * Get deleted records (for "Deleted Items" view)
   * @param {string} tableName - Table to query
   * @param {number} entityId - Entity filter (optional)
   * @returns {Promise<Array>} Deleted records with metadata
   */
  async getDeleted(tableName, entityId = null) {
    let results = await db[tableName].toArray();
    results = results.filter(r => r.deleted_at !== null && r.deleted_at !== undefined);

    if (entityId) {
      results = results.filter(r => r.entity_id === entityId);
    }

    // Add metadata for UI
    const now = Date.now();
    return results.map(r => {
      const deletedDate = new Date(r.deleted_at);
      const daysSinceDeleted = Math.floor((now - deletedDate.getTime()) / (1000 * 60 * 60 * 24));
      const canRestore = daysSinceDeleted <= this.RESTORE_WINDOW_DAYS;

      return {
        ...r,
        _daysSinceDeleted: daysSinceDeleted,
        _canRestore: canRestore,
        _restoreDeadline: canRestore
          ? new Date(deletedDate.getTime() + (this.RESTORE_WINDOW_DAYS * 24 * 60 * 60 * 1000)).toISOString()
          : null
      };
    });
  },

  /**
   * Auto-purge records deleted more than RETENTION_YEARS ago
   * Called on app initialization
   * @returns {Promise<{table: string, count: number}[]>} Purge results
   */
  async autoPurgeOldRecords() {
    const cutoffDate = new Date();
    cutoffDate.setFullYear(cutoffDate.getFullYear() - this.RETENTION_YEARS);
    const cutoff = cutoffDate.toISOString();

    const results = [];

    for (const tableName of this.SOFT_DELETE_TABLES) {
      try {
        const oldRecords = await db[tableName]
          .filter(r => r.deleted_at && r.deleted_at < cutoff)
          .toArray();

        if (oldRecords.length > 0) {
          const ids = oldRecords.map(r => r.id);
          await db[tableName].bulkDelete(ids);

          // Queue hard deletes for sync
          for (const record of oldRecords) {
            await SyncQueue.queueChange(tableName, record.id, 'DELETE', { id: record.id });
          }

          results.push({ table: tableName, count: oldRecords.length });
          console.log(`Auto-purged ${oldRecords.length} records from ${tableName} (deleted before ${cutoff})`);
        }
      } catch (error) {
        console.error(`Error purging ${tableName}:`, error);
      }
    }

    return results;
  },

  /**
   * Check if record is within restore window
   * @param {object} record - Record with deleted_at field
   * @returns {boolean} Can restore
   */
  canRestore(record) {
    if (!record.deleted_at) return false;
    const deletedDate = new Date(record.deleted_at);
    const daysSinceDeleted = (Date.now() - deletedDate.getTime()) / (1000 * 60 * 60 * 24);
    return daysSinceDeleted <= this.RESTORE_WINDOW_DAYS;
  }
};
```
  </action>
  <verify>
Test in browser console:

```javascript
// Create test record
const testId = await db.expenses.add({
  entity_id: 1,
  category: 'test',
  vendor: 'Test Vendor',
  amount_cents: 10000,
  deleted_at: null,
  ...auditFields(true)
});

// Verify active query includes it
let active = await DataManager.getActive('expenses', 1);
console.log('Active count:', active.length); // Should include test

// Soft delete
await DataManager.softDelete('expenses', testId);

// Verify excluded from active
active = await DataManager.getActive('expenses', 1);
console.log('After delete, active count:', active.length); // Should exclude test

// Verify appears in deleted
let deleted = await DataManager.getDeleted('expenses', 1);
console.log('Deleted count:', deleted.length); // Should include test
console.log('Can restore:', deleted.find(d => d.id === testId)?._canRestore); // true

// Restore
await DataManager.restore('expenses', testId);
active = await DataManager.getActive('expenses', 1);
console.log('After restore, active count:', active.length); // Should include test again

// Cleanup
await db.expenses.delete(testId);
```
  </verify>
  <done>
Soft delete system implemented with 30-day restore window and 4-year auto-purge. Active/deleted queries correctly filter records.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Sync Queue Infrastructure</name>
  <files>autonomo_dashboard.html</files>
  <action>
Add the SyncQueue module BEFORE DataManager (since DataManager uses it):

```javascript
// =====================================================
// Sync Queue (Offline-First)
// =====================================================

const SyncQueue = {
  // Warning thresholds
  WARN_THRESHOLD: 100,
  ALERT_THRESHOLD: 500,
  CRITICAL_THRESHOLD: 1000,

  /**
   * Queue a data change for eventual sync
   * @param {string} tableName - Table that changed
   * @param {number} recordId - Record ID
   * @param {string} operation - 'CREATE', 'UPDATE', 'DELETE'
   * @param {object} data - Changed data
   * @returns {Promise<number>} Queue entry ID
   */
  async queueChange(tableName, recordId, operation, data) {
    const entry = {
      table_name: tableName,
      record_id: recordId,
      operation: operation,
      data: JSON.stringify(data),
      created_at: new Date().toISOString(),
      retry_count: 0,
      last_error: null
    };

    const id = await db.sync_queue.add(entry);
    await this.updateIndicator();

    console.log(`Queued: ${operation} ${tableName}/${recordId}`);
    return id;
  },

  /**
   * Get pending sync queue count
   * @returns {Promise<number>} Count
   */
  async getPendingCount() {
    return db.sync_queue.count();
  },

  /**
   * Get all pending queue entries
   * @returns {Promise<Array>} Queue entries
   */
  async getPending() {
    return db.sync_queue.orderBy('created_at').toArray();
  },

  /**
   * Update the sync status indicator in UI
   */
  async updateIndicator() {
    const count = await this.getPendingCount();
    let indicator = document.getElementById('sync-indicator');

    // Create indicator if it doesn't exist
    if (!indicator) {
      indicator = this.createIndicator();
    }

    // Update status
    const statusEl = indicator.querySelector('.sync-status-text');
    const badgeEl = indicator.querySelector('.sync-badge');

    if (count === 0) {
      statusEl.textContent = 'Synced';
      indicator.className = 'sync-indicator synced';
      badgeEl.style.display = 'none';
    } else {
      statusEl.textContent = `${count} pending`;
      indicator.className = 'sync-indicator pending';
      badgeEl.textContent = count > 99 ? '99+' : count;
      badgeEl.style.display = 'flex';

      // Check thresholds and show warnings
      if (count >= this.CRITICAL_THRESHOLD) {
        indicator.classList.add('critical');
        this.showWarning('critical', count);
      } else if (count >= this.ALERT_THRESHOLD) {
        indicator.classList.add('alert');
        this.showWarning('alert', count);
      } else if (count >= this.WARN_THRESHOLD) {
        this.showWarning('warn', count);
      }
    }
  },

  /**
   * Create the sync indicator UI element
   * @returns {HTMLElement} Indicator element
   */
  createIndicator() {
    const indicator = document.createElement('div');
    indicator.id = 'sync-indicator';
    indicator.className = 'sync-indicator synced';
    indicator.innerHTML = `
      <svg class="sync-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M21 12a9 9 0 11-9-9 9.75 9.75 0 016.74 2.74"/>
        <path d="M21 3v9h-9"/>
      </svg>
      <span class="sync-status-text">Synced</span>
      <span class="sync-badge" style="display: none;">0</span>
    `;

    // Add click handler to show queue details
    indicator.addEventListener('click', () => this.showQueueDetails());

    // Insert into page (top-right corner)
    document.body.appendChild(indicator);
    return indicator;
  },

  /**
   * Show warning notification for large queue
   * @param {string} level - 'warn', 'alert', 'critical'
   * @param {number} count - Queue count
   */
  showWarning(level, count) {
    // Avoid repeated warnings (only show once per session per threshold)
    const key = `sync_warning_${level}`;
    if (sessionStorage.getItem(key)) return;
    sessionStorage.setItem(key, 'shown');

    const messages = {
      warn: `You have ${count} unsynced changes. Consider connecting to sync.`,
      alert: `Warning: ${count} unsynced changes. Connect to sync soon to avoid data loss.`,
      critical: `Critical: ${count} unsynced changes! Connect immediately to sync your data.`
    };

    console.warn(`[SyncQueue] ${messages[level]}`);

    // Show UI notification if available (Phase 5 notification system)
    if (typeof showNotification === 'function') {
      showNotification({
        type: level === 'critical' ? 'error' : 'warning',
        message: messages[level],
        duration: level === 'critical' ? 0 : 10000 // Critical stays until dismissed
      });
    }
  },

  /**
   * Show queue details modal/panel
   */
  async showQueueDetails() {
    const entries = await this.getPending();
    console.log('Sync queue entries:', entries);

    // Group by table
    const byTable = {};
    for (const entry of entries) {
      if (!byTable[entry.table_name]) {
        byTable[entry.table_name] = { CREATE: 0, UPDATE: 0, DELETE: 0 };
      }
      byTable[entry.table_name][entry.operation]++;
    }

    console.table(byTable);

    // Simple alert for now (replace with modal in UI phase)
    if (entries.length > 0) {
      const summary = Object.entries(byTable)
        .map(([table, ops]) => `${table}: ${ops.CREATE}C/${ops.UPDATE}U/${ops.DELETE}D`)
        .join('\n');
      alert(`Sync Queue (${entries.length} items)\n\n${summary}\n\nCloud sync coming in Phase 27.`);
    } else {
      alert('All data is synced!');
    }
  },

  /**
   * Clear sync queue (for testing or after successful sync)
   * @param {number[]} ids - Specific IDs to clear (optional, clears all if not provided)
   */
  async clearQueue(ids = null) {
    if (ids) {
      await db.sync_queue.bulkDelete(ids);
    } else {
      await db.sync_queue.clear();
    }
    await this.updateIndicator();
  }
};
```

Add CSS for the sync indicator (in the style section):

```css
/* Sync Indicator (Phase 12) */
.sync-indicator {
  position: fixed;
  top: var(--spacing-md);
  right: var(--spacing-md);
  display: flex;
  align-items: center;
  gap: var(--spacing-xs);
  padding: var(--spacing-xs) var(--spacing-sm);
  background: var(--bg-surface);
  border-radius: var(--radius-md);
  font-size: var(--size-small);
  cursor: pointer;
  z-index: 1000;
  transition: background 0.2s, box-shadow 0.2s;
}

.sync-indicator:hover {
  background: var(--bg-elevated);
}

.sync-indicator.synced {
  color: var(--positive);
}

.sync-indicator.pending {
  color: var(--warning);
}

.sync-indicator.alert {
  color: var(--negative);
  box-shadow: 0 0 0 2px var(--negative);
}

.sync-indicator.critical {
  color: var(--negative);
  animation: pulse 1s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% { box-shadow: 0 0 0 2px var(--negative); }
  50% { box-shadow: 0 0 0 4px var(--negative); }
}

.sync-icon {
  flex-shrink: 0;
}

.sync-badge {
  display: flex;
  align-items: center;
  justify-content: center;
  min-width: 20px;
  height: 20px;
  padding: 0 6px;
  background: var(--warning);
  color: var(--bg);
  border-radius: 10px;
  font-size: 11px;
  font-weight: 600;
}

.sync-indicator.alert .sync-badge,
.sync-indicator.critical .sync-badge {
  background: var(--negative);
}
```

Update initializeDatabase to include sync indicator and auto-purge:

```javascript
// Update the initializeDatabase function to add maintenance steps:

async function initializeDatabase() {
  const loadingScreen = document.getElementById('loading-screen');
  const loadingStatus = document.getElementById('loading-status');

  try {
    loadingScreen.classList.add('visible');

    // Step 1: Open database
    loadingStatus.textContent = 'Opening database...';
    await db.open();
    console.log('Database opened:', db.name, 'version:', db.verno);

    // Step 2: Run maintenance (auto-purge)
    loadingStatus.textContent = 'Running maintenance...';
    const purged = await DataManager.autoPurgeOldRecords();
    if (purged.length > 0) {
      console.log('Auto-purge results:', purged);
    }

    // Step 3: Check sync status
    loadingStatus.textContent = 'Checking sync status...';
    await SyncQueue.updateIndicator();

    // Step 4: Verify tables
    loadingStatus.textContent = 'Verifying schema...';
    const tables = db.tables.map(t => t.name);
    console.log('Database tables:', tables);

    // Success
    loadingScreen.classList.remove('visible');
    console.log('Database initialized successfully');
    return true;

  } catch (error) {
    console.error('Database initialization failed:', error);
    loadingStatus.textContent = `Error: ${error.message}`;
    loadingStatus.classList.add('error');
    return false;
  }
}
```
  </action>
  <verify>
Test in browser console:

```javascript
// Check sync indicator appears
console.log(document.getElementById('sync-indicator')); // Should exist

// Test queueing
await SyncQueue.queueChange('expenses', 1, 'CREATE', { test: true });
await SyncQueue.queueChange('expenses', 2, 'UPDATE', { test: true });

// Check count updated
console.log(await SyncQueue.getPendingCount()); // Should be 2

// Click indicator to see details
document.getElementById('sync-indicator').click();

// Clear for next tests
await SyncQueue.clearQueue();
console.log(await SyncQueue.getPendingCount()); // Should be 0
```

Also verify indicator:
- Shows in top-right corner
- Shows "Synced" when empty (green)
- Shows "2 pending" after adding items (orange)
- Badge shows count
  </verify>
  <done>
Sync queue infrastructure implemented with visual indicator, warning thresholds, and queue details view. All CRUD operations can be tracked for eventual cloud sync.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Soft delete workflow:**
   ```javascript
   // Full workflow test
   const id = await db.expenses.add({
     entity_id: 1, vendor: 'Test', amount_cents: 5000,
     deleted_at: null, ...auditFields(true)
   });

   // Active includes it
   let active = await DataManager.getActive('expenses', 1);
   console.assert(active.some(e => e.id === id), 'Should be in active');

   // Soft delete
   await DataManager.softDelete('expenses', id);

   // Active excludes it
   active = await DataManager.getActive('expenses', 1);
   console.assert(!active.some(e => e.id === id), 'Should not be in active');

   // Deleted includes it
   const deleted = await DataManager.getDeleted('expenses', 1);
   const item = deleted.find(e => e.id === id);
   console.assert(item, 'Should be in deleted');
   console.assert(item._canRestore === true, 'Should be restorable');

   // Restore
   await DataManager.restore('expenses', id);
   active = await DataManager.getActive('expenses', 1);
   console.assert(active.some(e => e.id === id), 'Should be back in active');

   // Cleanup
   await db.expenses.delete(id);
   await SyncQueue.clearQueue();
   console.log('Soft delete workflow: PASS');
   ```

2. **Sync queue workflow:**
   ```javascript
   // Check indicator
   const indicator = document.getElementById('sync-indicator');
   console.assert(indicator, 'Sync indicator exists');

   // Queue operations get tracked
   const queueId = await SyncQueue.queueChange('clients', 99, 'CREATE', { name: 'Test' });
   console.assert(queueId > 0, 'Queue entry created');

   const count = await SyncQueue.getPendingCount();
   console.assert(count >= 1, 'Queue has pending items');

   // Clear
   await SyncQueue.clearQueue();
   console.assert(await SyncQueue.getPendingCount() === 0, 'Queue cleared');
   console.log('Sync queue workflow: PASS');
   ```

3. **Visual checks:**
   - Sync indicator in top-right corner
   - Click indicator shows queue details
   - Adding items updates badge
</verification>

<success_criteria>
- Soft delete prevents physical deletion of financial records
- 30-day restore window enforced
- 4-year auto-purge runs on initialization
- All data changes queued for sync
- Sync indicator shows queue status visually
- Warning thresholds trigger at 100/500/1000 items
</success_criteria>

<output>
After completion, create `.planning/phases/12-data-architecture-foundation/12-02-SUMMARY.md`
</output>

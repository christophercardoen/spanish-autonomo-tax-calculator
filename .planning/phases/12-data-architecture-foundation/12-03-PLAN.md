---
phase: 12-data-architecture-foundation
plan: 03
type: execute
wave: 3
depends_on: ["12-02"]
files_modified:
  - autonomo_dashboard.html
autonomous: false

must_haves:
  truths:
    - "Invoice numbers are sequential without gaps"
    - "Only draft invoices can be archived"
    - "Sent/paid invoices require factura rectificativa for corrections"
    - "Invoice series (F, R, S) maintain separate sequences"
    - "Data persists across browser refresh"
  artifacts:
    - path: "autonomo_dashboard.html"
      provides: "InvoiceManager with VeriFactu-compliant sequencing"
      contains: "getNextInvoiceNumber"
  key_links:
    - from: "InvoiceManager.getNextInvoiceNumber"
      to: "invoice_sequences table"
      via: "Dexie transaction"
      pattern: "db\\.transaction\\("
    - from: "InvoiceManager.archiveInvoice"
      to: "DataManager.softDelete"
      via: "status check"
      pattern: "status.*draft"
---

<objective>
Implement VeriFactu-compliant invoice sequence management and verify the complete data architecture with a human checkpoint.

Purpose: Spanish invoicing law (Real Decreto 1619/2012) requires sequential invoice numbers without gaps. This task ensures legal compliance and validates the entire data layer before building features on top.

Output: InvoiceManager module with compliant sequencing, plus verified data persistence.
</objective>

<execution_context>
@/Users/christophercardoen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/christophercardoen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-data-architecture-foundation/12-CONTEXT.md
@.planning/phases/12-data-architecture-foundation/12-RESEARCH.md
@.planning/phases/12-data-architecture-foundation/12-01-SUMMARY.md
@.planning/phases/12-data-architecture-foundation/12-02-SUMMARY.md
@autonomo_dashboard.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Invoice Sequence Manager</name>
  <files>autonomo_dashboard.html</files>
  <action>
Add the InvoiceManager module after DataManager (before initializeDatabase):

```javascript
// =====================================================
// Invoice Manager (VeriFactu Compliance)
// =====================================================

const InvoiceManager = {
  // Invoice series types
  SERIES: {
    F: 'F', // Factura ordinaria (regular invoice)
    R: 'R', // Factura rectificativa (correcting invoice)
    S: 'S'  // Factura simplificada (simplified invoice, <400 EUR)
  },

  // Invoice statuses
  STATUS: {
    DRAFT: 'draft',
    SENT: 'sent',
    PAID: 'paid',
    OVERDUE: 'overdue',
    ARCHIVED: 'archived'
  },

  /**
   * Get next invoice number in sequence (thread-safe via transaction)
   * Format: F-2026-0001, R-2026-0001, etc.
   * @param {number} entityId - Entity ID
   * @param {string} series - Invoice series (F, R, S)
   * @returns {Promise<string>} Invoice number
   */
  async getNextInvoiceNumber(entityId, series = 'F') {
    if (!Object.values(this.SERIES).includes(series)) {
      throw new Error(`Invalid invoice series: ${series}. Must be F, R, or S.`);
    }

    return db.transaction('rw', db.invoice_sequences, async () => {
      // Find or create sequence for this entity+series
      let seq = await db.invoice_sequences
        .where('[entity_id+series]')
        .equals([entityId, series])
        .first();

      if (!seq) {
        // First invoice in this series for this entity
        seq = {
          entity_id: entityId,
          series: series,
          last_number: 0
        };
        seq.id = await db.invoice_sequences.add(seq);
      }

      // Increment sequence
      seq.last_number++;
      await db.invoice_sequences.update(seq.id, { last_number: seq.last_number });

      // Format: {series}-{year}-{4-digit-padded-number}
      const year = new Date().getFullYear();
      const paddedNum = String(seq.last_number).padStart(4, '0');
      return `${series}-${year}-${paddedNum}`;
    });
  },

  /**
   * Get current sequence number (without incrementing)
   * @param {number} entityId - Entity ID
   * @param {string} series - Invoice series
   * @returns {Promise<number>} Current last number
   */
  async getCurrentNumber(entityId, series = 'F') {
    const seq = await db.invoice_sequences
      .where('[entity_id+series]')
      .equals([entityId, series])
      .first();

    return seq ? seq.last_number : 0;
  },

  /**
   * Archive an invoice (soft delete for drafts only)
   * VeriFactu requires: sent/paid invoices CANNOT be deleted
   * @param {number} invoiceId - Invoice ID
   * @returns {Promise<boolean>} Success
   */
  async archiveInvoice(invoiceId) {
    const invoice = await db.invoices.get(invoiceId);

    if (!invoice) {
      throw new Error(`Invoice not found: ${invoiceId}`);
    }

    if (invoice.deleted_at) {
      throw new Error('Invoice already archived');
    }

    // CRITICAL: Only draft invoices can be archived
    if (invoice.status !== this.STATUS.DRAFT) {
      throw new Error(
        `Cannot archive ${invoice.status} invoice. ` +
        `VeriFactu requires sent/paid invoices to remain in sequence. ` +
        `To correct errors, create a factura rectificativa (series R). ` +
        `To cancel the operation, issue a credit note.`
      );
    }

    // Archive (soft delete) the draft
    const now = new Date().toISOString();
    const changes = {
      deleted_at: now,
      status: this.STATUS.ARCHIVED,
      ...auditFields(false)
    };

    await db.invoices.update(invoiceId, changes);
    await SyncQueue.queueChange('invoices', invoiceId, 'UPDATE', changes);

    console.log(`Archived draft invoice: ${invoice.invoice_number}`);
    return true;
  },

  /**
   * Create a rectifying invoice (factura rectificativa)
   * Links to original invoice and uses series 'R'
   * @param {number} originalInvoiceId - Original invoice to correct
   * @param {object} corrections - Correction data
   * @returns {Promise<{id: number, invoice_number: string}>}
   */
  async createRectifyingInvoice(originalInvoiceId, corrections) {
    const original = await db.invoices.get(originalInvoiceId);

    if (!original) {
      throw new Error(`Original invoice not found: ${originalInvoiceId}`);
    }

    if (original.status === this.STATUS.DRAFT) {
      throw new Error('Cannot create rectificativa for draft invoice. Edit the draft directly.');
    }

    if (original.deleted_at) {
      throw new Error('Cannot create rectificativa for archived invoice.');
    }

    // Valid correction reasons (per Real Decreto 1619/2012 Art. 15)
    const validReasons = [
      'error_datos_fiscales',     // Error in fiscal data (NIF, name, address)
      'modificacion_base',        // Modification of taxable base
      'descuento_posterior',      // Subsequent discount
      'devolucion_envases',       // Return of packaging
      'impago_concurso',          // Non-payment in insolvency proceedings
      'otros'                     // Other (requires description)
    ];

    if (!corrections.reason || !validReasons.includes(corrections.reason)) {
      throw new Error(`Invalid correction reason. Must be one of: ${validReasons.join(', ')}`);
    }

    // Get next R-series number
    const invoiceNumber = await this.getNextInvoiceNumber(original.entity_id, this.SERIES.R);

    const rectifying = {
      entity_id: original.entity_id,
      client_id: original.client_id,
      series: this.SERIES.R,
      invoice_number: invoiceNumber,
      status: this.STATUS.DRAFT,
      date_issued: new Date().toISOString().split('T')[0],
      date_due: null,

      // Link to original
      original_invoice_id: original.id,
      original_invoice_number: original.invoice_number,
      correction_reason: corrections.reason,
      correction_description: corrections.description || null,

      // Amounts (negative for credit, positive for debit)
      subtotal_cents: corrections.subtotal_cents || 0,
      iva_cents: corrections.iva_cents || 0,
      irpf_cents: corrections.irpf_cents || 0,
      total_cents: corrections.total_cents || 0,

      deleted_at: null,
      ...auditFields(true)
    };

    const id = await db.invoices.add(rectifying);
    await SyncQueue.queueChange('invoices', id, 'CREATE', rectifying);

    console.log(`Created rectifying invoice: ${invoiceNumber} for original: ${original.invoice_number}`);
    return { id, invoice_number: invoiceNumber };
  },

  /**
   * Get all invoices for an entity (active only by default)
   * @param {number} entityId - Entity ID
   * @param {object} options - Query options
   * @returns {Promise<Array>} Invoices
   */
  async getInvoices(entityId, options = {}) {
    const { includeArchived = false, status = null, series = null } = options;

    let query = db.invoices.where('entity_id').equals(entityId);
    let results = await query.toArray();

    // Filter archived unless requested
    if (!includeArchived) {
      results = results.filter(inv => !inv.deleted_at);
    }

    // Filter by status if specified
    if (status) {
      results = results.filter(inv => inv.status === status);
    }

    // Filter by series if specified
    if (series) {
      results = results.filter(inv => inv.series === series);
    }

    // Sort by date descending
    return results.sort((a, b) => b.date_issued.localeCompare(a.date_issued));
  },

  /**
   * Validate invoice number format
   * @param {string} invoiceNumber - Number to validate
   * @returns {boolean} Is valid
   */
  isValidInvoiceNumber(invoiceNumber) {
    // Format: {series}-{year}-{number}
    const pattern = /^[FRS]-\d{4}-\d{4,}$/;
    return pattern.test(invoiceNumber);
  },

  /**
   * Parse invoice number components
   * @param {string} invoiceNumber - Number to parse
   * @returns {{series: string, year: number, number: number}|null}
   */
  parseInvoiceNumber(invoiceNumber) {
    if (!this.isValidInvoiceNumber(invoiceNumber)) return null;

    const [series, year, num] = invoiceNumber.split('-');
    return {
      series,
      year: parseInt(year, 10),
      number: parseInt(num, 10)
    };
  }
};
```
  </action>
  <verify>
Test in browser console:

```javascript
// Test sequence generation
const testEntityId = 999;

// Get first number
const num1 = await InvoiceManager.getNextInvoiceNumber(testEntityId, 'F');
console.log('First F invoice:', num1); // F-2026-0001

// Get second number
const num2 = await InvoiceManager.getNextInvoiceNumber(testEntityId, 'F');
console.log('Second F invoice:', num2); // F-2026-0002

// Get R-series number (separate sequence)
const numR = await InvoiceManager.getNextInvoiceNumber(testEntityId, 'R');
console.log('First R invoice:', numR); // R-2026-0001

// Verify F-series continues correctly
const num3 = await InvoiceManager.getNextInvoiceNumber(testEntityId, 'F');
console.log('Third F invoice:', num3); // F-2026-0003

// Verify sequence is persistent
console.log('Current F number:', await InvoiceManager.getCurrentNumber(testEntityId, 'F')); // 3
console.log('Current R number:', await InvoiceManager.getCurrentNumber(testEntityId, 'R')); // 1

// Cleanup test sequences
await db.invoice_sequences.where('entity_id').equals(testEntityId).delete();

// Test validation
console.log('Valid F-2026-0001:', InvoiceManager.isValidInvoiceNumber('F-2026-0001')); // true
console.log('Invalid ABC-123:', InvoiceManager.isValidInvoiceNumber('ABC-123')); // false
```
  </verify>
  <done>
Invoice sequence manager implemented with thread-safe number generation, series support (F/R/S), and VeriFactu compliance rules. Sent/paid invoices protected from deletion.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify Complete Data Architecture</name>
  <what-built>
Complete Phase 12 data architecture:
1. Dexie.js database with 12-table schema
2. MoneyUtils for integer cents handling
3. DataManager for soft delete with 4-year retention
4. SyncQueue for offline-first operation
5. InvoiceManager for VeriFactu-compliant sequencing
  </what-built>
  <how-to-verify>
**Step 1: Database Persistence Test**
1. Open the app at http://localhost:3013/autonomo_dashboard.html
2. Open DevTools (F12) > Application > IndexedDB
3. Verify 'AutonomoBusinessDB' exists with these tables:
   - entities, clients, projects
   - invoices, invoice_lines, invoice_sequences
   - expenses, receipts
   - calendar_days, tax_calculations
   - sync_queue, settings

**Step 2: Loading Screen Test**
1. Hard refresh (Cmd+Shift+R or Ctrl+Shift+R)
2. Watch for loading screen with spinner
3. Should show "Opening database..." then "Running maintenance..." then disappear

**Step 3: Sync Indicator Test**
1. Look for sync indicator in top-right corner
2. Should show "Synced" (green) initially
3. Run in console: `await SyncQueue.queueChange('test', 1, 'CREATE', {})`
4. Indicator should change to "1 pending" (orange)
5. Click indicator to see queue details
6. Run: `await SyncQueue.clearQueue()` to reset

**Step 4: Money Conversion Test**
Run in console and verify outputs:
```javascript
// Input: User types euros, stored as cents
console.log('100 EUR =', MoneyUtils.eurosToCents('100'), 'cents'); // 10000
console.log('99.99 EUR =', MoneyUtils.eurosToCents('99.99'), 'cents'); // 9999
console.log('1,234.56 EUR =', MoneyUtils.eurosToCents('1,234.56'), 'cents'); // 123456

// Output: Cents displayed as formatted euros
console.log('12345 cents =', MoneyUtils.formatEuros(12345)); // "123,45 EUR" (Spanish format)
console.log('21% IVA of 10000 cents =', MoneyUtils.calculateIVA(10000, 0.21), 'cents'); // 2100
```

**Step 5: Data Persistence Test**
1. Run in console:
```javascript
const testId = await db.settings.put({ key: 'test_persist', value: 'hello', updated_at: new Date().toISOString() });
console.log('Saved setting with key: test_persist');
```
2. Hard refresh the page
3. Run: `await db.settings.get('test_persist')`
4. Should return the saved object with value "hello"
5. Clean up: `await db.settings.delete('test_persist')`

**Step 6: Invoice Sequence Test**
Run in console:
```javascript
const num1 = await InvoiceManager.getNextInvoiceNumber(888, 'F');
const num2 = await InvoiceManager.getNextInvoiceNumber(888, 'F');
const numR = await InvoiceManager.getNextInvoiceNumber(888, 'R');
console.log('Sequence test:', num1, num2, numR);
// Should show: F-2026-0001, F-2026-0002, R-2026-0001
await db.invoice_sequences.where('entity_id').equals(888).delete(); // cleanup
```

**Step 7: Existing v1.1 Functionality**
1. Navigate to the Scenario Comparison section
2. Verify scenario cards still display correctly
3. Check that expense tracking still works
4. Confirm calendar still functions

**Expected Results:**
- All 7 steps pass
- No console errors
- v1.1 functionality unaffected
  </how-to-verify>
  <resume-signal>Type "approved" if all tests pass, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
Phase 12 success criteria from ROADMAP.md:

1. [x] User data persists in IndexedDB across browser sessions
   - Verified via Step 5 persistence test

2. [x] All currency amounts stored as integers (cents)
   - MoneyUtils.eurosToCents() converts input
   - MoneyUtils.formatEuros() displays output

3. [x] Deleted records retained with deleted_at timestamp (soft delete for 4-year retention)
   - DataManager.softDelete() sets timestamp
   - DataManager.autoPurgeOldRecords() cleans up 4+ years

4. [x] Offline changes queued for future sync
   - SyncQueue.queueChange() tracks all operations
   - Visual indicator shows pending count

5. [x] Schema migrations handle version upgrades gracefully
   - Dexie version() with upgrade() pattern ready
   - Loading screen shows migration status
</verification>

<success_criteria>
- SYNC-01 complete: System stores data in IndexedDB via Dexie.js
- Invoice sequences are VeriFactu compliant (no gaps, series separation)
- All financial calculations use integer cents
- Soft delete preserves records for 4-year audit retention
- Sync queue tracks all changes for Phase 27
- Human verified data persists and v1.1 still works
</success_criteria>

<output>
After completion, create `.planning/phases/12-data-architecture-foundation/12-03-SUMMARY.md`
</output>

---
phase: 16-calendar-enhancement
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - autonomo_dashboard.html
autonomous: true

must_haves:
  truths:
    - "Calendar data persists in IndexedDB across browser sessions"
    - "Calendar operations are entity-scoped (only see current entity's days)"
    - "Migration from localStorage completes without data loss"
  artifacts:
    - path: "autonomo_dashboard.html"
      provides: "CalendarManager module"
      contains: "const CalendarManager"
    - path: "autonomo_dashboard.html"
      provides: "Migration function"
      contains: "migrateCalendarToIndexedDB"
  key_links:
    - from: "CalendarManager"
      to: "db.calendar_days"
      via: "Dexie table operations"
      pattern: "db\\.calendar_days"
    - from: "CalendarManager"
      to: "EntityContext.entityId"
      via: "entity_id field"
      pattern: "entity_id.*EntityContext"
---

<objective>
Create CalendarManager module for IndexedDB CRUD operations and migrate existing localStorage calendar data.

Purpose: Establish the data layer foundation for all Phase 16 calendar features
Output: CalendarManager module with getDay, saveDay, getDaysForMonth, deleteDays; migration function that runs once
</objective>

<execution_context>
@/Users/christophercardoen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/christophercardoen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-calendar-enhancement/16-RESEARCH.md
@autonomo_dashboard.html (lines 12190-12300 for schema, 7840-8020 for existing calendar)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement CalendarManager Module</name>
  <files>autonomo_dashboard.html</files>
  <action>
Add CalendarManager module after EntityContext (around line 12600) with:

1. Constants for LOCATION_TYPE (replaces DAY_STATUS):
   - BELGIUM: 'belgium'
   - SPAIN: 'spain'
   - TRAVEL: 'travel'
   - OTHER: 'other'
   - Keep UNSET for compatibility: 'unset'

2. CalendarManager object with methods:
   - getDay(dateKey): Get single day by ISO date key for current entity
   - saveDay(dateKey, data): Upsert day record with location, client_id, project_id, notes
   - getDaysForMonth(year, month): Get all days for a month (0-indexed month)
   - getDaysForYear(year): Get all days for a year (for 183-day calculation)
   - getDaysInRange(startDate, endDate): Get days between two ISO date keys
   - deleteDays(dateKeys): Bulk delete days (for clearing selections)
   - getLinkedExpenseCount(dateKey): Placeholder returning 0 (Phase 17 will implement)

3. All methods must:
   - Use EntityContext.entityId for entity scoping
   - Use db.calendar_days table
   - Handle async/await properly
   - Update updated_at timestamp on save

4. Pattern for compound index query:
   ```javascript
   db.calendar_days
     .where('[entity_id+date]')
     .equals([entityId, dateKey])
     .first()
   ```

Do NOT modify the existing calendar rendering code yet - that comes in later plans.
  </action>
  <verify>
Console test:
- `await CalendarManager.saveDay('2026-02-15', {location: 'belgium'})` - no error
- `await CalendarManager.getDay('2026-02-15')` - returns object with location: 'belgium'
- `await CalendarManager.getDaysForMonth(2026, 1)` - returns array including saved day
  </verify>
  <done>
CalendarManager module exists with all CRUD methods entity-scoped to current entity
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement localStorage to IndexedDB Migration</name>
  <files>autonomo_dashboard.html</files>
  <action>
Add migration function after CalendarManager:

1. Create migrateCalendarToIndexedDB async function:
   - Check localStorage for CALENDAR_MIGRATION_KEY ('calendar_migrated_v2_entity_{entityId}')
   - If already migrated for this entity, return early
   - Read 'autonomo_calendar_v1' from localStorage
   - Parse days object from old format
   - For each day, create new record:
     ```javascript
     {
       entity_id: EntityContext.entityId,
       date: dateKey,
       location: oldDay.status === 'unset' ? null : oldDay.status,
       client_id: null,  // v1 had no client data
       project_id: null,
       notes: oldDay.contracted ? 'Contracted day (migrated from v1)' : null,
       created_at: new Date().toISOString(),
       updated_at: new Date().toISOString()
     }
     ```
   - Use db.calendar_days.bulkPut for batch insert
   - Set migration flag per-entity in localStorage

2. Call migrateCalendarToIndexedDB() in initializeDatabase() AFTER EntityContext.initialize()
   - Only if EntityContext.entityId is set (user has an entity)

3. Add error handling with console.warn for migration failures (non-blocking)

4. Log migration results: "Calendar migration complete: {N} days migrated for entity {entityId}"
  </action>
  <verify>
Migration test sequence:
1. With existing v1 calendar data in localStorage, refresh page
2. Check console for "Calendar migration complete" message
3. Verify data in DevTools > Application > IndexedDB > calendar_days
4. Refresh again - should NOT re-migrate (check for "already migrated" or no migration log)
  </verify>
  <done>
Migration function runs once per entity, converts localStorage calendar to IndexedDB without data loss
  </done>
</task>

</tasks>

<verification>
1. CalendarManager module exists with documented methods
2. Migration function handles both fresh installs and existing v1 data
3. Entity scoping works - different entities have separate calendar data
4. No errors in browser console on page load
</verification>

<success_criteria>
- CalendarManager provides all CRUD operations for calendar days
- Migration preserves all v1 calendar entries in IndexedDB
- Entity-scoping isolates calendar data per business entity
- Placeholder for expense linking ready for Phase 17
</success_criteria>

<output>
After completion, create `.planning/phases/16-calendar-enhancement/16-01-SUMMARY.md`
</output>

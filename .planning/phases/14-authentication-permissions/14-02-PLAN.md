---
phase: 14-authentication-permissions
plan: 02
type: execute
wave: 2
depends_on: [14-01]
files_modified:
  - autonomo_dashboard.html
autonomous: true
user_setup:
  - service: supabase
    why: "Authentication backend for magic link, Google OAuth, and session management"
    env_vars:
      - name: SUPABASE_URL
        source: "Supabase Dashboard > Project Settings > API > Project URL"
      - name: SUPABASE_ANON_KEY
        source: "Supabase Dashboard > Project Settings > API > anon public key"
    dashboard_config:
      - task: "Enable Email Auth with Magic Link"
        location: "Supabase Dashboard > Authentication > Providers > Email"
      - task: "Configure Google OAuth"
        location: "Supabase Dashboard > Authentication > Providers > Google"
      - task: "Set Site URL and Redirect URLs"
        location: "Supabase Dashboard > Authentication > URL Configuration"

must_haves:
  truths:
    - "User can enter email and receive magic link"
    - "User can click Google sign-in button and authenticate"
    - "Auth callback properly exchanges code for session"
    - "Authenticated session persists across page refresh"
    - "Unauthenticated users see auth required state"
  artifacts:
    - path: "autonomo_dashboard.html"
      provides: "Supabase client initialization"
      contains: "createClient"
    - path: "autonomo_dashboard.html"
      provides: "AuthManager module"
      contains: "signInWithOtp"
  key_links:
    - from: "AuthManager.signInWithMagicLink"
      to: "supabase.auth.signInWithOtp"
      via: "Supabase Auth API"
      pattern: "signInWithOtp.*email"
    - from: "AuthManager.signInWithGoogle"
      to: "supabase.auth.signInWithOAuth"
      via: "Supabase OAuth"
      pattern: "signInWithOAuth.*google"
---

<objective>
Supabase Auth client integration with magic link and Google OAuth

Purpose: Enable user authentication via Supabase Auth - users must be able to sign in before any entity ownership or permissions can be established
Output: AuthManager module with magic link, Google OAuth, session persistence, and auth state management
</objective>

<execution_context>
@/Users/christophercardoen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/christophercardoen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-authentication-permissions/14-RESEARCH.md
@.planning/phases/14-authentication-permissions/14-01-SUMMARY.md

Key patterns from 14-RESEARCH.md:
- Magic link: supabase.auth.signInWithOtp({ email, options: { shouldCreateUser: true, emailRedirectTo } })
- Google OAuth: supabase.auth.signInWithOAuth({ provider: 'google', options: { redirectTo } })
- Callback: supabase.auth.exchangeCodeForSession(code)
- Session check: supabase.auth.getSession()
- Auth state listener: supabase.auth.onAuthStateChange()
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Supabase client and AuthManager module</name>
  <files>autonomo_dashboard.html</files>
  <action>
1. Add Supabase CDN script in the head section (near ExcelJS CDN, around line ~15):
```html
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
```

2. Add Supabase configuration constants after the ENTITY_TYPE constants (around line ~9850):
```javascript
// Supabase Configuration
// These values should be set from environment or config
// For local development, they can be hardcoded temporarily
const SUPABASE_CONFIG = {
  url: '', // Set from Supabase Dashboard > Project Settings > API > Project URL
  anonKey: '', // Set from Supabase Dashboard > Project Settings > API > anon public key
  // Note: In production, these should come from environment variables
  // For single-file HTML, we accept hardcoding during development
};

// Initialize Supabase client (will be null if config not set)
let supabase = null;
function initializeSupabase() {
  if (SUPABASE_CONFIG.url && SUPABASE_CONFIG.anonKey) {
    supabase = window.supabase.createClient(
      SUPABASE_CONFIG.url,
      SUPABASE_CONFIG.anonKey
    );
    console.log('Supabase client initialized');
    return true;
  } else {
    console.warn('Supabase config not set - auth features disabled. Running in offline-only mode.');
    return false;
  }
}
```

3. Add AuthManager module after the Supabase initialization:
```javascript
const AuthManager = {
  currentUser: null,
  currentSession: null,
  authStateListeners: [],
  localSessionId: null,

  // Initialize auth state
  async initialize() {
    if (!supabase) {
      console.log('AuthManager: Running in offline mode (no Supabase)');
      return null;
    }

    // Check for OAuth callback (code in URL)
    const url = new URL(window.location.href);
    const code = url.searchParams.get('code');
    if (code) {
      await this.handleOAuthCallback(code);
      // Clean URL
      window.history.replaceState({}, document.title, window.location.pathname);
    }

    // Get current session
    const { data: { session }, error } = await supabase.auth.getSession();
    if (error) {
      console.error('Auth session error:', error);
      return null;
    }

    if (session) {
      this.currentSession = session;
      this.currentUser = session.user;
      await this.onAuthSuccess(session);
    }

    // Listen for auth state changes
    supabase.auth.onAuthStateChange(async (event, session) => {
      console.log('Auth state change:', event);
      this.currentSession = session;
      this.currentUser = session?.user || null;

      if (event === 'SIGNED_IN' && session) {
        await this.onAuthSuccess(session);
      } else if (event === 'SIGNED_OUT') {
        await this.onSignOut();
      }

      // Notify listeners
      this.authStateListeners.forEach(listener => listener(event, session));
    });

    return session;
  },

  // Magic link sign in (AUTH-01, AUTH-02)
  async signInWithMagicLink(email) {
    if (!supabase) {
      throw new Error('Supabase not configured. Please set SUPABASE_CONFIG.');
    }

    const redirectTo = `${window.location.origin}${window.location.pathname}`;
    const { data, error } = await supabase.auth.signInWithOtp({
      email,
      options: {
        shouldCreateUser: true,
        emailRedirectTo: redirectTo
      }
    });

    if (error) throw error;
    return { success: true, message: 'Check your email for the login link' };
  },

  // Google OAuth sign in
  async signInWithGoogle() {
    if (!supabase) {
      throw new Error('Supabase not configured. Please set SUPABASE_CONFIG.');
    }

    const redirectTo = `${window.location.origin}${window.location.pathname}`;
    const { data, error } = await supabase.auth.signInWithOAuth({
      provider: 'google',
      options: {
        redirectTo
      }
    });

    if (error) throw error;
    // User will be redirected to Google
  },

  // Handle OAuth callback
  async handleOAuthCallback(code) {
    if (!supabase) return;

    const { data, error } = await supabase.auth.exchangeCodeForSession(code);
    if (error) {
      console.error('OAuth callback error:', error);
      throw error;
    }
    return data.session;
  },

  // Called after successful authentication
  async onAuthSuccess(session) {
    const user = session.user;
    console.log('User authenticated:', user.email);

    // Upsert profile from auth metadata
    await ProfileManager.upsertProfile(user.id, {
      email: user.email,
      name: user.user_metadata?.name || user.user_metadata?.full_name || null
    });

    // Record session
    this.localSessionId = await SessionManager.recordSession(user.id, {
      deviceName: SessionManager.detectDeviceName()
    });

    // Claim ownership of entities without owner
    await this.claimOrphanedEntities(user.id);
  },

  // Claim entities that don't have an owner (migration from v1)
  async claimOrphanedEntities(userId) {
    const entities = await db.entities
      .filter(e => !e.owner_id && !e.deleted_at)
      .toArray();

    for (const entity of entities) {
      await db.entities.update(entity.id, { owner_id: userId });
      console.log(`Claimed entity ${entity.id} for user ${userId}`);
    }
  },

  // Sign out (AUTH-06)
  async signOut(scope = 'local') {
    if (!supabase) return;

    // scope: 'local' (this device), 'global' (all devices), 'others' (other devices)
    const { error } = await supabase.auth.signOut({ scope });
    if (error) throw error;
  },

  async onSignOut() {
    // Clean up local session record
    if (this.localSessionId) {
      await SessionManager.revokeSession(this.localSessionId);
      this.localSessionId = null;
    }
    this.currentUser = null;
    this.currentSession = null;
  },

  // Subscribe to auth state changes
  onAuthStateChange(listener) {
    this.authStateListeners.push(listener);
    // Return unsubscribe function
    return () => {
      this.authStateListeners = this.authStateListeners.filter(l => l !== listener);
    };
  },

  // Check if user is authenticated
  isAuthenticated() {
    return !!this.currentUser;
  },

  // Get current user
  getUser() {
    return this.currentUser;
  },

  // Get current session
  getSession() {
    return this.currentSession;
  },

  // Check if running in offline mode (no Supabase)
  isOfflineMode() {
    return !supabase;
  }
};
```

4. Update the initializeDatabase function to include Supabase and Auth initialization:
Add before Step 1 (around line ~10100):
```javascript
// Step 0: Initialize Supabase (if configured)
updateStatus('Checking authentication...');
const supabaseReady = initializeSupabase();
if (supabaseReady) {
  await AuthManager.initialize();
}
```
  </action>
  <verify>
1. Page loads without errors
2. Console shows either:
   - "Supabase client initialized" (if config set)
   - "Supabase config not set - auth features disabled" (if not set)
3. AuthManager is accessible from console
4. AuthManager.isOfflineMode() returns true (until config is set)
  </verify>
  <done>
Supabase client initialized (or gracefully degraded to offline mode), AuthManager module with signInWithMagicLink, signInWithGoogle, signOut methods available
  </done>
</task>

<task type="auto">
  <name>Task 2: Add password reset functionality</name>
  <files>autonomo_dashboard.html</files>
  <action>
Extend AuthManager with password reset capability (AUTH-03):

Add these methods to the AuthManager object:

```javascript
// Password reset (AUTH-03)
async requestPasswordReset(email) {
  if (!supabase) {
    throw new Error('Supabase not configured');
  }

  const redirectTo = `${window.location.origin}${window.location.pathname}`;
  const { data, error } = await supabase.auth.resetPasswordForEmail(email, {
    redirectTo
  });

  if (error) throw error;
  return { success: true, message: 'Check your email for the password reset link' };
},

// Update password (called after clicking reset link)
async updatePassword(newPassword) {
  if (!supabase) {
    throw new Error('Supabase not configured');
  }

  const { data, error } = await supabase.auth.updateUser({
    password: newPassword
  });

  if (error) throw error;
  return { success: true, message: 'Password updated successfully' };
},

// Check if this is a password recovery session
isRecoverySession() {
  if (!this.currentSession) return false;
  // Supabase sets this when user clicks password reset link
  const url = new URL(window.location.href);
  return url.searchParams.get('type') === 'recovery';
}
```

Also update the handleOAuthCallback to handle recovery tokens:

```javascript
// Handle OAuth callback - update to handle recovery
async handleOAuthCallback(code) {
  if (!supabase) return;

  // Check if this is a recovery flow
  const url = new URL(window.location.href);
  const type = url.searchParams.get('type');

  const { data, error } = await supabase.auth.exchangeCodeForSession(code);
  if (error) {
    console.error('OAuth callback error:', error);
    throw error;
  }

  // If recovery, don't auto-redirect - let UI handle password update
  if (type === 'recovery') {
    console.log('Password recovery session detected');
    // UI should show password update form
  }

  return data.session;
},
```
  </action>
  <verify>
Console: AuthManager.requestPasswordReset (function exists)
Console: AuthManager.updatePassword (function exists)
Console: AuthManager.isRecoverySession() returns false (normal session)
  </verify>
  <done>
Password reset flow methods added: requestPasswordReset, updatePassword, isRecoverySession
  </done>
</task>

<task type="auto">
  <name>Task 3: Add entity ownership helper methods</name>
  <files>autonomo_dashboard.html</files>
  <action>
Add EntityAccessManager module to handle ownership and permission checks:

```javascript
const EntityAccessManager = {
  // Check if user can access entity (owner or shared)
  async canAccess(entityId, userId = null) {
    const uid = userId || AuthManager.getUser()?.id;
    if (!uid) return false;

    // Check ownership
    const entity = await db.entities.get(entityId);
    if (!entity) return false;
    if (entity.owner_id === uid) return true;

    // Check shares
    const share = await db.entity_shares
      .where('[entity_id+user_id]').equals([entityId, uid])
      .filter(s => s.accepted_at !== null)
      .first();

    return !!share;
  },

  // Get user's role for entity
  async getRole(entityId, userId = null) {
    const uid = userId || AuthManager.getUser()?.id;
    if (!uid) return null;

    // Check ownership
    const entity = await db.entities.get(entityId);
    if (!entity) return null;
    if (entity.owner_id === uid) return 'owner';

    // Check shares
    const share = await db.entity_shares
      .where('[entity_id+user_id]').equals([entityId, uid])
      .filter(s => s.accepted_at !== null)
      .first();

    return share?.role || null;
  },

  // Check if user can perform action
  async canPerformAction(entityId, action, userId = null) {
    const role = await this.getRole(entityId, userId);
    if (!role) return false;

    const permissions = {
      owner: ['view', 'edit', 'create', 'delete', 'invite', 'manage', 'archive_entity', 'delete_entity'],
      partner: ['view', 'edit', 'create', 'delete', 'invite', 'manage', 'archive_entity'],
      accountant: ['view', 'edit', 'create'], // No delete, no invite
      gestor: ['view', 'export'] // Read-only
    };

    return permissions[role]?.includes(action) || false;
  },

  // Get all entities user can access
  async getAccessibleEntities(userId = null) {
    const uid = userId || AuthManager.getUser()?.id;
    if (!uid) return [];

    // Get owned entities
    const ownedEntities = await db.entities
      .filter(e => e.owner_id === uid && !e.deleted_at)
      .toArray();

    // Get shared entities
    const shares = await db.entity_shares
      .where('user_id').equals(uid)
      .filter(s => s.accepted_at !== null)
      .toArray();

    const sharedEntityIds = shares.map(s => s.entity_id);
    const sharedEntities = await db.entities
      .where('id').anyOf(sharedEntityIds)
      .filter(e => !e.deleted_at)
      .toArray();

    // Merge and deduplicate
    const all = [...ownedEntities, ...sharedEntities];
    const seen = new Set();
    return all.filter(e => {
      if (seen.has(e.id)) return false;
      seen.add(e.id);
      return true;
    });
  },

  // Transfer entity ownership
  async transferOwnership(entityId, newOwnerId) {
    const entity = await db.entities.get(entityId);
    if (!entity) throw new Error('Entity not found');

    const currentUserId = AuthManager.getUser()?.id;
    if (entity.owner_id !== currentUserId) {
      throw new Error('Only the owner can transfer ownership');
    }

    await db.entities.update(entityId, { owner_id: newOwnerId });
    console.log(`Ownership of entity ${entityId} transferred to ${newOwnerId}`);
  }
};
```

Update EntityManager (if it exists from Phase 13) to check ownership when creating entities:

Find the EntityManager.create method and add owner_id assignment:
```javascript
// In EntityManager.create, add owner_id to entity data:
const entityData = {
  ...data,
  owner_id: AuthManager.getUser()?.id || null,
  created_at: now,
  updated_at: now,
  deleted_at: null
};
```

If EntityManager doesn't have a create method that sets owner_id, add a wrapper:
```javascript
// After EntityManager definition, add ownership injection
const originalCreateEntity = EntityManager.create?.bind(EntityManager);
if (originalCreateEntity) {
  EntityManager.create = async function(data) {
    const entityData = {
      ...data,
      owner_id: AuthManager.getUser()?.id || null
    };
    return await originalCreateEntity(entityData);
  };
}
```
  </action>
  <verify>
Console tests:
- EntityAccessManager.canAccess (function exists)
- EntityAccessManager.getRole (function exists)
- EntityAccessManager.canPerformAction (function exists)
- EntityAccessManager.getAccessibleEntities() returns array
  </verify>
  <done>
EntityAccessManager module with canAccess, getRole, canPerformAction, getAccessibleEntities, transferOwnership methods
  </done>
</task>

</tasks>

<verification>
1. Open autonomo_dashboard.html in browser
2. Check console for Supabase initialization message
3. Verify all modules accessible:
   - AuthManager.signInWithMagicLink
   - AuthManager.signInWithGoogle
   - AuthManager.signOut
   - AuthManager.requestPasswordReset
   - EntityAccessManager.canAccess
   - EntityAccessManager.getRole
4. No JavaScript errors in console
5. App functions normally in offline mode (SUPABASE_CONFIG empty)
</verification>

<success_criteria>
- Supabase CDN script loaded
- Supabase client initializes (or gracefully degrades to offline mode)
- AuthManager handles magic link, Google OAuth, password reset, signout
- Auth callback handles code exchange
- EntityAccessManager checks ownership and permissions
- Session persistence works (refresh page maintains auth state if Supabase configured)
- New entities get owner_id set to current user
</success_criteria>

<output>
After completion, create `.planning/phases/14-authentication-permissions/14-02-SUMMARY.md`
</output>

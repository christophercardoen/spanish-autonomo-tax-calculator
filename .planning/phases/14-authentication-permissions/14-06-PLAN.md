---
phase: 14-authentication-permissions
plan: 06
type: execute
wave: 6
depends_on: [14-05]
files_modified:
  - autonomo_dashboard.html
autonomous: false

must_haves:
  truths:
    - "Gestor can view all data but cannot edit anything"
    - "Accountant can edit expenses but cannot delete invoices"
    - "Partner has full access except entity deletion"
    - "UI elements disabled/hidden based on user role"
    - "Permission denied shows helpful message"
    - "Entity list shows only accessible entities"
  artifacts:
    - path: "autonomo_dashboard.html"
      provides: "Role-based UI restrictions"
      contains: "checkPermission"
    - path: "autonomo_dashboard.html"
      provides: "Permission helper functions"
      contains: "canPerformAction"
  key_links:
    - from: "UI action buttons"
      to: "EntityAccessManager.canPerformAction"
      via: "permission check before render"
      pattern: "canPerformAction.*edit"
    - from: "entity list"
      to: "EntityAccessManager.getAccessibleEntities"
      via: "filtered entity query"
      pattern: "getAccessibleEntities"
---

<objective>
Permission enforcement in UI with role-based access control

Purpose: Enforce Gestor/Accountant/Partner/Owner permissions at UI level so users cannot perform actions beyond their role (PERM-04, PERM-06, PERM-07)
Output: Role-aware UI with disabled/hidden elements, permission checks before actions, entity list filtering
</objective>

<execution_context>
@/Users/christophercardoen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/christophercardoen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-authentication-permissions/14-CONTEXT.md
@.planning/phases/14-authentication-permissions/14-05-SUMMARY.md

Key decisions from 14-CONTEXT.md:
- Gestor (read-only): Can view everything, export all visible data. Cannot modify anything.
- Accountant (read-write): View clients only (no create/edit). No invoice creation - can only view. Works on categorizing expenses.
- Partner (full admin): Full data access. Can invite users, change roles, manage everything except delete the entity.
- Owner (implicit): Full admin plus can delete entity and transfer ownership.

PERM requirements:
- PERM-04: User sees only entities they own or have been granted access to
- PERM-06: Accountant role cannot delete invoices/expenses (only edit)
- PERM-07: Gestor role can view and export reports but not modify data
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add PermissionUI helper module</name>
  <files>autonomo_dashboard.html</files>
  <action>
Add PermissionUI module for centralized permission checking and UI updates:

```javascript
const PermissionUI = {
  // Cache current role to avoid repeated DB queries
  currentEntityRole: null,

  // Permission map: role -> allowed actions
  PERMISSIONS: {
    owner: ['view', 'edit', 'create', 'delete', 'invite', 'manage', 'export', 'archive_entity', 'delete_entity', 'transfer_ownership'],
    partner: ['view', 'edit', 'create', 'delete', 'invite', 'manage', 'export', 'archive_entity'],
    accountant: ['view', 'edit', 'create', 'export'], // Can edit/create expenses, but see restriction checks below
    gestor: ['view', 'export']
  },

  // Additional restrictions for accountant
  ACCOUNTANT_RESTRICTIONS: {
    // Cannot delete anything
    canDelete: false,
    // Cannot create/edit invoices
    canCreateInvoice: false,
    canEditInvoice: false,
    // Cannot create/edit clients
    canCreateClient: false,
    canEditClient: false,
    // CAN edit expenses (their primary function)
    canEditExpense: true,
    canCreateExpense: true
  },

  // Update role cache when entity changes
  async updateRoleCache() {
    const currentEntity = EntityContext.getCurrentEntity();
    if (!currentEntity) {
      this.currentEntityRole = null;
      return null;
    }

    const user = AuthManager.getUser();
    if (!user) {
      this.currentEntityRole = null;
      return null;
    }

    this.currentEntityRole = await EntityAccessManager.getRole(currentEntity.id, user.id);
    return this.currentEntityRole;
  },

  // Get current role (use cache if available)
  async getRole() {
    if (this.currentEntityRole === null) {
      await this.updateRoleCache();
    }
    return this.currentEntityRole;
  },

  // Check if current user can perform action
  async canPerform(action, context = {}) {
    const role = await this.getRole();
    if (!role) return false;

    // Base permission check
    const allowed = this.PERMISSIONS[role]?.includes(action);
    if (!allowed) return false;

    // Additional checks for accountant
    if (role === 'accountant') {
      // Check specific restrictions
      if (action === 'delete') return false;

      if (context.type === 'invoice') {
        if (action === 'create' || action === 'edit') return false;
      }

      if (context.type === 'client') {
        if (action === 'create' || action === 'edit') return false;
      }
    }

    return true;
  },

  // Quick check methods for common actions
  async canView() {
    return await this.canPerform('view');
  },

  async canEdit(type) {
    return await this.canPerform('edit', { type });
  },

  async canCreate(type) {
    return await this.canPerform('create', { type });
  },

  async canDelete(type) {
    return await this.canPerform('delete', { type });
  },

  async canExport() {
    return await this.canPerform('export');
  },

  async canInvite() {
    return await this.canPerform('invite');
  },

  async canManage() {
    return await this.canPerform('manage');
  },

  // Apply permissions to UI elements
  async applyToUI() {
    const role = await this.getRole();
    const isOffline = AuthManager.isOfflineMode();

    // In offline mode, allow full access (local data only)
    if (isOffline) {
      document.querySelectorAll('[data-permission]').forEach(el => {
        el.style.display = '';
        el.disabled = false;
        el.classList.remove('permission-disabled');
      });
      return;
    }

    if (!role) {
      // No access - hide all permission-gated elements
      document.querySelectorAll('[data-permission]').forEach(el => {
        el.style.display = 'none';
      });
      return;
    }

    // Apply permission checks to each element
    document.querySelectorAll('[data-permission]').forEach(async (el) => {
      const requiredAction = el.getAttribute('data-permission');
      const contextType = el.getAttribute('data-permission-type');

      const allowed = await this.canPerform(requiredAction, { type: contextType });

      if (el.tagName === 'BUTTON' || el.tagName === 'INPUT' || el.tagName === 'SELECT') {
        // For interactive elements, disable instead of hide
        el.disabled = !allowed;
        if (!allowed) {
          el.classList.add('permission-disabled');
          el.title = `Requires ${requiredAction} permission`;
        } else {
          el.classList.remove('permission-disabled');
          el.title = '';
        }
      } else {
        // For containers/divs, hide entirely
        el.style.display = allowed ? '' : 'none';
      }
    });

    // Update role indicator if exists
    this.updateRoleIndicator(role);
  },

  // Show role indicator in header/entity area
  updateRoleIndicator(role) {
    const indicator = document.getElementById('current-role-indicator');
    if (!indicator) return;

    if (!role) {
      indicator.style.display = 'none';
      return;
    }

    const roleLabels = {
      owner: 'Owner',
      partner: 'Partner',
      accountant: 'Accountant',
      gestor: 'Gestor (View Only)'
    };

    indicator.textContent = roleLabels[role] || role;
    indicator.className = `role-indicator role-${role}`;
    indicator.style.display = '';
  },

  // Show permission denied message
  showDenied(action) {
    const role = this.currentEntityRole;
    const roleLabel = {
      gestor: 'Gestor (view only)',
      accountant: 'Accountant',
      partner: 'Partner',
      owner: 'Owner'
    }[role] || role;

    const message = `Permission denied: Your role (${roleLabel}) cannot ${action}.`;
    alert(message);
    return false;
  },

  // Initialize - subscribe to entity changes
  init() {
    // Update role when entity changes
    EntityContext.subscribe(async () => {
      await this.updateRoleCache();
      await this.applyToUI();
    });

    // Update role when auth changes
    AuthManager.onAuthStateChange(async () => {
      await this.updateRoleCache();
      await this.applyToUI();
    });
  }
};
```

Add CSS for permission-disabled state:

```css
/* Permission-based UI styles */
.permission-disabled {
  opacity: 0.5;
  cursor: not-allowed !important;
}

.role-indicator {
  font-size: 11px;
  padding: 2px 8px;
  border-radius: 10px;
  margin-left: 8px;
}

.role-indicator.role-owner {
  background: rgba(168, 85, 247, 0.2);
  color: #a855f7;
}

.role-indicator.role-partner {
  background: rgba(34, 197, 94, 0.2);
  color: #22c55e;
}

.role-indicator.role-accountant {
  background: rgba(59, 130, 246, 0.2);
  color: #3b82f6;
}

.role-indicator.role-gestor {
  background: rgba(234, 179, 8, 0.2);
  color: #eab308;
}

/* Read-only mode indicator for gestors */
.read-only-banner {
  background: rgba(234, 179, 8, 0.1);
  border: 1px solid rgba(234, 179, 8, 0.2);
  color: #eab308;
  padding: 8px 16px;
  font-size: 13px;
  text-align: center;
  display: none;
}

.read-only-banner.visible {
  display: block;
}
```
  </action>
  <verify>
Console: PermissionUI.canPerform('edit') (returns promise)
Console: PermissionUI.PERMISSIONS (object with role mappings)
  </verify>
  <done>
PermissionUI module with role caching, permission checking, UI element application, role indicator
  </done>
</task>

<task type="auto">
  <name>Task 2: Apply permission attributes to existing UI elements</name>
  <files>autonomo_dashboard.html</files>
  <action>
Add data-permission attributes to existing UI elements that need permission gating.

1. Add role indicator to header (near entity switcher or user menu):

```html
<span id="current-role-indicator" class="role-indicator" style="display: none;"></span>
```

2. Add read-only banner (show for gestors):

```html
<div id="read-only-banner" class="read-only-banner">
  You have view-only access. Contact the owner to request edit permissions.
</div>
```

3. Apply permission attributes to action buttons throughout the app.

Search for common action buttons and add data-permission attributes:

**For Create/Add buttons:**
```html
<!-- Example: Add expense button -->
<button data-permission="create" data-permission-type="expense" onclick="...">
  Add Expense
</button>

<!-- Example: Create invoice button -->
<button data-permission="create" data-permission-type="invoice" onclick="...">
  Create Invoice
</button>

<!-- Example: Add client button -->
<button data-permission="create" data-permission-type="client" onclick="...">
  Add Client
</button>
```

**For Edit buttons:**
```html
<!-- Example: Edit expense button -->
<button data-permission="edit" data-permission-type="expense" onclick="...">
  Edit
</button>
```

**For Delete buttons:**
```html
<!-- Example: Delete button -->
<button data-permission="delete" onclick="...">
  Delete
</button>
```

**For entity management:**
```html
<!-- Archive entity -->
<button data-permission="archive_entity" onclick="...">
  Archive Entity
</button>

<!-- Invite button in sharing section -->
<button id="sharing-invite-btn" data-permission="invite" onclick="InviteUI.openModal()">
  + Invite User
</button>
```

4. Add permission wrapper function for programmatic actions:

```javascript
// Wrapper to check permission before executing action
async function withPermission(action, type, callback) {
  const allowed = await PermissionUI.canPerform(action, { type });
  if (!allowed) {
    PermissionUI.showDenied(action);
    return false;
  }
  return await callback();
}

// Example usage in existing code:
// Before: someDeleteFunction()
// After: await withPermission('delete', 'expense', () => someDeleteFunction())
```

5. Update read-only banner visibility:

Add to PermissionUI.applyToUI():
```javascript
// Show read-only banner for gestors
const readOnlyBanner = document.getElementById('read-only-banner');
if (readOnlyBanner) {
  readOnlyBanner.classList.toggle('visible', role === 'gestor');
}
```

6. For form inputs that should be read-only for gestors, add logic:

```javascript
// Make form inputs read-only for gestors
if (role === 'gestor') {
  document.querySelectorAll('input:not([type="search"]), select, textarea').forEach(el => {
    if (!el.closest('.auth-form') && !el.closest('.search-form')) {
      el.setAttribute('readonly', true);
      el.classList.add('permission-disabled');
    }
  });
}
```

Note: The exact elements to mark depend on the current UI structure. Apply data-permission to all buttons that trigger create/edit/delete actions. Key areas:
- Expense management buttons
- Invoice management buttons (if they exist)
- Client management buttons (if they exist)
- Entity management (archive, delete)
- Sharing/invite functionality
  </action>
  <verify>
1. As owner: All buttons enabled
2. As partner: All buttons enabled except entity delete
3. As accountant: Invoice/client create buttons disabled, expense buttons work
4. As gestor: All modify buttons disabled, read-only banner shows
  </verify>
  <done>
Permission attributes applied to UI elements, withPermission wrapper available, role indicator in header, read-only banner for gestors
  </done>
</task>

<task type="auto">
  <name>Task 3: Filter entity list by accessible entities</name>
  <files>autonomo_dashboard.html</files>
  <action>
Update entity-related queries to filter by accessible entities (PERM-04).

1. Find EntitySwitcher or entity list loading code and update to use EntityAccessManager:

```javascript
// In EntitySwitcher/EntityList loading function
async function loadEntityList() {
  // Old code might be:
  // const entities = await db.entities.filter(e => !e.deleted_at).toArray();

  // New code - filter by access:
  let entities;

  if (AuthManager.isOfflineMode()) {
    // Offline mode: show all local entities
    entities = await db.entities.filter(e => !e.deleted_at).toArray();
  } else if (AuthManager.isAuthenticated()) {
    // Online: show only accessible entities
    entities = await EntityAccessManager.getAccessibleEntities();
  } else {
    entities = [];
  }

  return entities;
}
```

2. If EntitySwitcherUI exists (from Phase 13), update its load/refresh method:

Find EntitySwitcherUI.refresh or similar and update:
```javascript
// In EntitySwitcherUI
async refresh() {
  const entities = AuthManager.isOfflineMode()
    ? await db.entities.filter(e => !e.deleted_at).toArray()
    : await EntityAccessManager.getAccessibleEntities();

  // ... rest of rendering code
}
```

3. Add role badge to entity list items:

When rendering entity items, show the user's role:
```javascript
// In entity list item rendering
async function renderEntityItem(entity) {
  const role = await EntityAccessManager.getRole(entity.id);
  const roleLabel = {
    owner: 'Owner',
    partner: 'Partner',
    accountant: 'Accountant',
    gestor: 'Gestor'
  }[role] || '';

  return `
    <div class="entity-item">
      <span class="entity-name">${escapeHtml(entity.name)}</span>
      ${role !== 'owner' ? `<span class="role-indicator role-${role}">${roleLabel}</span>` : ''}
    </div>
  `;
}
```

4. Initialize PermissionUI on app load:

Add to app initialization (after EntityContext, AuthManager):
```javascript
PermissionUI.init();
```

5. Ensure permission refresh when switching entities:

In entity switch handler:
```javascript
// When entity is switched
async function onEntitySwitch(entityId) {
  // ... existing entity switch logic ...

  // Refresh permissions
  await PermissionUI.updateRoleCache();
  await PermissionUI.applyToUI();
}
```
  </action>
  <verify>
1. Create two entities as owner
2. Invite another user (create dummy share in console) with gestor role
3. That user's entity list shows only their accessible entities
4. Entity items show role badge (except for owner)
  </verify>
  <done>
Entity list filters by accessible entities, shows role badges, permission UI refreshes on entity switch
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete authentication and permissions system:
- Magic link and Google OAuth sign-in
- User profile management with NIF/CIF validation
- 2FA enrollment and verification
- Active session management
- Entity sharing with role-based invitations
- Permission enforcement in UI (Gestor/Accountant/Partner/Owner)
  </what-built>
  <how-to-verify>
1. **Authentication Flow:**
   - Open autonomo_dashboard.html
   - If Supabase not configured, verify "Continue without sign in" works (offline mode)
   - If Supabase configured:
     - Enter email and click "Continue with Email" - verify magic link sent
     - Click Google button - verify redirect to Google OAuth
     - After sign in, verify dashboard appears

2. **Profile Management:**
   - Click user menu in header
   - Click "Profile"
   - Enter name, NIF, phone, address
   - Click Save - verify "Profile updated successfully"
   - Enter invalid NIF - verify validation error in Spanish

3. **2FA (requires Supabase):**
   - In Profile, find 2FA toggle
   - Click "Enable" - verify QR code modal
   - Scan with authenticator app
   - Enter 6-digit code - verify "2FA enabled successfully"

4. **Sessions:**
   - Click "Active Sessions" in user menu
   - Verify current session shows with "Current" badge
   - Verify "Sign out all other devices" button present

5. **Entity Sharing:**
   - Select an entity
   - Find "Team Access" section
   - Click "Invite User"
   - Select role (Gestor), leave email blank
   - Click "Create Invitation"
   - Verify shareable link and code displayed

6. **Permission Enforcement:**
   - As owner: All buttons should be enabled
   - To test other roles:
     - Console: `await EntityShareManager.addShare(1, 'test-user-id', 'gestor', null)`
     - Verify gestor sees read-only banner
     - Verify gestor cannot click edit/delete buttons
  </how-to-verify>
  <resume-signal>Type "approved" if all flows work correctly, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
1. Complete authentication flow (magic link or Google or offline)
2. Profile editable with validation
3. 2FA enrollment works (if Supabase configured)
4. Session list displays correctly
5. Entity invitation creates shareable link/code
6. Permission UI enforces role restrictions
7. Entity list filters by accessible entities
8. No JavaScript errors throughout
</verification>

<success_criteria>
- User can only see entities they own or have been granted access to (PERM-04)
- Accountant cannot delete invoices/expenses (PERM-06)
- Gestor can view and export but not modify (PERM-07)
- Permission denied messages are helpful
- Role indicator shows in header/entity area
- Read-only banner for gestors
- All interactive elements respect permission state
- withPermission wrapper available for programmatic checks
</success_criteria>

<output>
After completion, create `.planning/phases/14-authentication-permissions/14-06-SUMMARY.md`
</output>

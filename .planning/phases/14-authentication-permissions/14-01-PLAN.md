---
phase: 14-authentication-permissions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - autonomo_dashboard.html
autonomous: true

must_haves:
  truths:
    - "Entities table has owner_id column referencing auth user"
    - "profiles table exists with user profile fields"
    - "entity_shares table tracks user-entity-role relationships"
    - "entity_invitations table tracks pending invitations with expiry"
    - "user_sessions table tracks active sessions per user"
    - "RLS enabled on all new tables"
  artifacts:
    - path: "autonomo_dashboard.html"
      provides: "Database schema v2 with auth tables"
      contains: "profiles"
    - path: "autonomo_dashboard.html"
      provides: "entity_shares junction table"
      contains: "entity_shares"
  key_links:
    - from: "entities.owner_id"
      to: "auth.users(id)"
      via: "foreign key reference"
      pattern: "owner_id.*UUID"
    - from: "entity_shares.user_id"
      to: "auth.users(id)"
      via: "foreign key reference"
      pattern: "user_id.*UUID"
---

<objective>
Database schema extension for multi-user authentication and permissions

Purpose: Establish the data foundation for user accounts, entity ownership, and role-based sharing - required before any auth UI can be built
Output: Database schema v2 with profiles, entity_shares, entity_invitations, user_sessions tables + owner_id on entities
</objective>

<execution_context>
@/Users/christophercardoen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/christophercardoen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-authentication-permissions/14-RESEARCH.md

Key schema patterns from 14-RESEARCH.md:
- profiles: id (UUID, PK, refs auth.users), name, email, nif_cif, phone, address, created_at, updated_at
- entity_shares: id, entity_id, user_id, role CHECK ('gestor','accountant','partner'), invited_by, invited_at, accepted_at, UNIQUE(entity_id, user_id)
- entity_invitations: id, entity_id, email, invite_code UNIQUE, role, invited_by, created_at, expires_at, used_at, used_by
- user_sessions: id, user_id, device_name, user_agent, ip_address, location, last_active_at, created_at
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend database schema with auth tables</name>
  <files>autonomo_dashboard.html</files>
  <action>
In the AppDatabase class (within the autonomo_dashboard.html script section, around line ~9700-9800), extend the Dexie schema to version 2:

1. Add owner_id column to entities table (nullable initially for migration)
2. Add new tables:

```javascript
// In AppDatabase constructor, update version:
this.version(2).stores({
  // Existing tables (preserve exactly as-is)
  entities: '++id, type, tax_id, name, entity_id, deleted_at',
  clients: '++id, entity_id, tax_id, name, deleted_at, [entity_id+deleted_at]',
  projects: '++id, entity_id, client_id, name, deleted_at, [entity_id+deleted_at]',
  invoices: '++id, entity_id, client_id, number, status, deleted_at, [entity_id+deleted_at]',
  invoice_lines: '++id, invoice_id, deleted_at',
  invoice_sequences: '++id, entity_id, series, year, [entity_id+series+year]',
  expenses: '++id, entity_id, category, date, deleted_at, [entity_id+deleted_at]',
  receipts: '++id, entity_id, expense_id, deleted_at, [entity_id+deleted_at]',
  calendar_days: '++id, entity_id, date, deleted_at, [entity_id+deleted_at], [entity_id+date]',
  tax_calculations: '++id, entity_id, period, type, deleted_at, [entity_id+deleted_at]',
  sync_queue: '++id, table_name, operation, synced_at',
  settings: 'key',

  // NEW: Auth tables for v2
  profiles: 'id, email',  // id is UUID from auth.users
  entity_shares: '++id, entity_id, user_id, [entity_id+user_id]',
  entity_invitations: '++id, entity_id, invite_code, email, expires_at',
  user_sessions: '++id, user_id, last_active_at'
});
```

3. Add upgrade function from v1 to v2:
```javascript
this.version(2).stores({...}).upgrade(tx => {
  // Add owner_id to existing entities (will be populated when user authenticates)
  return tx.entities.toCollection().modify(entity => {
    if (!entity.owner_id) {
      entity.owner_id = null; // Will be set on first auth
    }
  });
});
```

Note: Dexie.js uses IndexedDB which doesn't have true foreign keys or RLS. The RLS policies will be enforced when syncing to Supabase (Phase 27). For now, we're preparing the local schema structure.
  </action>
  <verify>
Open browser DevTools > Application > IndexedDB > AutonomoBusinessDB
Verify tables exist: profiles, entity_shares, entity_invitations, user_sessions
Console: `db.profiles.toArray()` returns empty array (no error)
Console: `db.entity_shares.toArray()` returns empty array (no error)
  </verify>
  <done>
Database schema v2 with all auth tables defined, entities has owner_id field, upgrade path from v1 works
  </done>
</task>

<task type="auto">
  <name>Task 2: Add helper functions for auth tables</name>
  <files>autonomo_dashboard.html</files>
  <action>
Add helper modules after the AppDatabase class definition (around line ~9850):

1. ProfileManager module:
```javascript
const ProfileManager = {
  async getProfile(userId) {
    return await db.profiles.get(userId);
  },

  async upsertProfile(userId, data) {
    const existing = await db.profiles.get(userId);
    const now = new Date().toISOString();

    if (existing) {
      await db.profiles.update(userId, {
        ...data,
        updated_at: now
      });
    } else {
      await db.profiles.add({
        id: userId,
        name: data.name || null,
        email: data.email || null,
        nif_cif: data.nif_cif || null,
        phone: data.phone || null,
        address: data.address || null,
        created_at: now,
        updated_at: now
      });
    }
    return await db.profiles.get(userId);
  }
};
```

2. EntityShareManager module:
```javascript
const EntityShareManager = {
  ROLES: Object.freeze({
    GESTOR: 'gestor',       // Read-only
    ACCOUNTANT: 'accountant', // Read-write, no delete
    PARTNER: 'partner'       // Full admin minus entity deletion
  }),

  async getShares(entityId) {
    return await db.entity_shares
      .where('entity_id').equals(entityId)
      .toArray();
  },

  async getUserShares(userId) {
    return await db.entity_shares
      .where('user_id').equals(userId)
      .filter(share => share.accepted_at !== null)
      .toArray();
  },

  async addShare(entityId, userId, role, invitedBy) {
    if (!Object.values(this.ROLES).includes(role)) {
      throw new Error(`Invalid role: ${role}. Must be one of: ${Object.values(this.ROLES).join(', ')}`);
    }

    const existing = await db.entity_shares
      .where('[entity_id+user_id]').equals([entityId, userId])
      .first();

    if (existing) {
      throw new Error('User already has access to this entity');
    }

    const now = new Date().toISOString();
    return await db.entity_shares.add({
      entity_id: entityId,
      user_id: userId,
      role,
      invited_by: invitedBy,
      invited_at: now,
      accepted_at: now  // Local shares are immediately accepted
    });
  },

  async removeShare(entityId, userId) {
    return await db.entity_shares
      .where('[entity_id+user_id]').equals([entityId, userId])
      .delete();
  },

  async getRole(entityId, userId) {
    const share = await db.entity_shares
      .where('[entity_id+user_id]').equals([entityId, userId])
      .first();
    return share?.role || null;
  }
};
```

3. InvitationManager module:
```javascript
const InvitationManager = {
  EXPIRY_DAYS: 7,

  async createInvitation(entityId, role, invitedBy, email = null) {
    const inviteCode = crypto.randomUUID();
    const now = new Date();
    const expiresAt = new Date(now.getTime() + this.EXPIRY_DAYS * 24 * 60 * 60 * 1000);

    const invitation = {
      entity_id: entityId,
      email: email,
      invite_code: inviteCode,
      role,
      invited_by: invitedBy,
      created_at: now.toISOString(),
      expires_at: expiresAt.toISOString(),
      used_at: null,
      used_by: null
    };

    await db.entity_invitations.add(invitation);
    return { ...invitation, inviteCode };
  },

  async getInvitation(inviteCode) {
    const invitation = await db.entity_invitations
      .where('invite_code').equals(inviteCode)
      .first();

    if (!invitation) return null;
    if (invitation.used_at) return null;
    if (new Date(invitation.expires_at) < new Date()) return null;

    return invitation;
  },

  async acceptInvitation(inviteCode, userId) {
    const invitation = await this.getInvitation(inviteCode);
    if (!invitation) {
      throw new Error('Invalid or expired invitation');
    }

    // Mark invitation as used
    await db.entity_invitations.update(invitation.id, {
      used_at: new Date().toISOString(),
      used_by: userId
    });

    // Create entity share
    await EntityShareManager.addShare(
      invitation.entity_id,
      userId,
      invitation.role,
      invitation.invited_by
    );

    return invitation;
  },

  async getPendingInvitations(entityId) {
    const now = new Date().toISOString();
    return await db.entity_invitations
      .where('entity_id').equals(entityId)
      .filter(inv => inv.used_at === null && inv.expires_at > now)
      .toArray();
  }
};
```

4. SessionManager module:
```javascript
const SessionManager = {
  async recordSession(userId, metadata = {}) {
    const now = new Date().toISOString();
    const sessionId = crypto.randomUUID();

    await db.user_sessions.add({
      id: sessionId,
      user_id: userId,
      device_name: metadata.deviceName || this.detectDeviceName(),
      user_agent: navigator.userAgent,
      ip_address: null, // Can only be set server-side
      location: null,   // Can only be set server-side
      last_active_at: now,
      created_at: now
    });

    return sessionId;
  },

  detectDeviceName() {
    const ua = navigator.userAgent;
    if (/iPhone/.test(ua)) return 'iPhone';
    if (/iPad/.test(ua)) return 'iPad';
    if (/Android/.test(ua)) return 'Android Device';
    if (/Mac/.test(ua)) return 'Mac';
    if (/Windows/.test(ua)) return 'Windows PC';
    if (/Linux/.test(ua)) return 'Linux';
    return 'Unknown Device';
  },

  async updateLastActive(sessionId) {
    await db.user_sessions.update(sessionId, {
      last_active_at: new Date().toISOString()
    });
  },

  async getSessions(userId) {
    return await db.user_sessions
      .where('user_id').equals(userId)
      .reverse()
      .sortBy('last_active_at');
  },

  async revokeSession(sessionId) {
    await db.user_sessions.delete(sessionId);
  },

  async revokeOtherSessions(userId, currentSessionId) {
    const sessions = await this.getSessions(userId);
    for (const session of sessions) {
      if (session.id !== currentSessionId) {
        await this.revokeSession(session.id);
      }
    }
  }
};
```
  </action>
  <verify>
Console tests:
- `EntityShareManager.ROLES` returns frozen object with gestor/accountant/partner
- `InvitationManager.EXPIRY_DAYS` returns 7
- `SessionManager.detectDeviceName()` returns string like "Mac" or "Windows PC"
  </verify>
  <done>
ProfileManager, EntityShareManager, InvitationManager, SessionManager modules exist and are callable from console
  </done>
</task>

</tasks>

<verification>
1. Open autonomo_dashboard.html in browser
2. DevTools > Application > IndexedDB > AutonomoBusinessDB shows:
   - profiles table (empty)
   - entity_shares table (empty)
   - entity_invitations table (empty)
   - user_sessions table (empty)
3. Console: All manager modules accessible and return expected types
4. No JavaScript errors in console
</verification>

<success_criteria>
- Database version upgraded from 1 to 2
- Four new auth tables created: profiles, entity_shares, entity_invitations, user_sessions
- entities table has owner_id field (nullable)
- ProfileManager, EntityShareManager, InvitationManager, SessionManager modules functional
- Existing v1 data preserved (migration runs without data loss)
</success_criteria>

<output>
After completion, create `.planning/phases/14-authentication-permissions/14-01-SUMMARY.md`
</output>

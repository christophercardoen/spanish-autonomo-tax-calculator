---
phase: 13-multi-entity-architecture
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [autonomo_dashboard.html]
autonomous: true

must_haves:
  truths:
    - "EntityContext.current returns the currently selected entity object"
    - "EntityContext.setEntity() persists selection to IndexedDB settings"
    - "EntityContext.subscribe() notifies observers when entity changes"
    - "Entity selection restored on page refresh from persisted setting"
  artifacts:
    - path: "autonomo_dashboard.html"
      provides: "EntityContext singleton module"
      contains: "const EntityContext"
  key_links:
    - from: "EntityContext.setEntity()"
      to: "db.settings"
      via: "put() with key 'current_entity_id'"
      pattern: "db\\.settings\\.put.*current_entity_id"
    - from: "EntityContext.initialize()"
      to: "db.settings.get('current_entity_id')"
      via: "restore persisted selection"
      pattern: "settings\\.get.*current_entity_id"
---

<objective>
Implement EntityContext singleton with observer pattern for managing current entity state across the application.

Purpose: Provides centralized entity state management that all UI components can subscribe to. When entity changes, all subscribed components automatically update to show that entity's data.

Output: EntityContext module with current getter, entityId getter, setEntity(), clear(), subscribe(), notify(), and initialize() methods. Persistence via IndexedDB settings table.
</objective>

<execution_context>
@/Users/christophercardoen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/christophercardoen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-multi-entity-architecture/13-RESEARCH.md
@.planning/phases/12-data-architecture-foundation/12-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement EntityContext singleton with observer pattern</name>
  <files>autonomo_dashboard.html</files>
  <action>
Add after the SpanishTaxIdValidator module (or after InvoiceManager if Plan 01 not yet executed):

```javascript
// =====================================================
// Entity Context (Current Entity State Management)
// =====================================================

const EntityContext = (() => {
  let currentEntity = null;
  const observers = new Set();

  return {
    // Get current entity object
    get current() {
      return currentEntity;
    },

    // Get current entity ID (convenience)
    get entityId() {
      return currentEntity?.id ?? null;
    },

    // Set current entity and notify observers
    async setEntity(entityId) {
      // Skip if already selected
      if (entityId === currentEntity?.id) return;

      // Fetch entity from database
      const entity = await db.entities.get(entityId);
      if (!entity) {
        throw new Error(`Entity ${entityId} not found`);
      }
      if (entity.deleted_at) {
        throw new Error(`Entity ${entityId} is deleted`);
      }
      if (!entity.is_active) {
        throw new Error(`Entity ${entityId} is archived`);
      }

      currentEntity = entity;

      // Persist selection to settings
      await db.settings.put({
        key: 'current_entity_id',
        value: entityId,
        updated_at: new Date().toISOString()
      });

      // Notify all observers
      this.notify();
    },

    // Clear entity (logout/no entity state)
    clear() {
      currentEntity = null;
      this.notify();
    },

    // Subscribe to entity changes
    subscribe(callback) {
      observers.add(callback);
      // Return unsubscribe function
      return () => observers.delete(callback);
    },

    // Notify all observers of entity change
    notify() {
      observers.forEach(callback => {
        try {
          callback(currentEntity);
        } catch (error) {
          console.error('EntityContext observer error:', error);
        }
      });
    },

    // Initialize from persisted selection (call on app startup)
    async initialize() {
      try {
        const setting = await db.settings.get('current_entity_id');
        if (setting?.value) {
          await this.setEntity(setting.value);
          return true;
        }
      } catch (error) {
        console.warn('Could not restore entity selection:', error);
      }
      return false;
    },

    // Get count of observers (for debugging)
    get observerCount() {
      return observers.size;
    }
  };
})();
```

Then update the `initializeDatabase()` function to call EntityContext.initialize() after database is ready:

Find the line `updateLoadingStatus('Ready');` near the end of initializeDatabase() and add before it:

```javascript
// Initialize entity context from persisted selection
updateLoadingStatus('Restoring session...');
const entityRestored = await EntityContext.initialize();
if (entityRestored) {
  console.log('Restored entity:', EntityContext.current?.name);
}
```
  </action>
  <verify>
Console tests (after creating a test entity):
```javascript
// Create test entity
const testEntityId = await db.entities.add({
  type: 'autonomo',
  nif_cif: '12345678Z',
  name: 'Test Autonomo',
  is_active: true,
  deleted_at: null,
  ...auditFields(true)
});

// Test EntityContext
console.log('Initial:', EntityContext.current); // null

// Subscribe to changes
let changeCount = 0;
const unsub = EntityContext.subscribe((entity) => {
  changeCount++;
  console.log('Observer called:', entity?.name);
});

// Set entity
await EntityContext.setEntity(testEntityId);
console.log('After set:', EntityContext.current?.name); // 'Test Autonomo'
console.log('Entity ID:', EntityContext.entityId); // testEntityId
console.log('Change count:', changeCount); // 1

// Verify persistence
const setting = await db.settings.get('current_entity_id');
console.log('Persisted:', setting.value === testEntityId); // true

// Unsubscribe
unsub();
await EntityContext.setEntity(testEntityId); // Re-set (no-op, same entity)
console.log('Change count after unsub:', changeCount); // still 1 (no new call)

// Clear
EntityContext.clear();
console.log('After clear:', EntityContext.current); // null

// Cleanup
await db.entities.delete(testEntityId);
await db.settings.delete('current_entity_id');
```
  </verify>
  <done>
- EntityContext.current returns selected entity object or null
- EntityContext.entityId returns entity ID or null
- EntityContext.setEntity() validates entity exists and is active, persists to settings
- EntityContext.subscribe() adds observer, returns unsubscribe function
- EntityContext.initialize() restores selection from settings on app load
- Observers notified on setEntity() and clear()
  </done>
</task>

</tasks>

<verification>
1. Page loads without errors
2. Create test entity and verify EntityContext methods work
3. Refresh page - EntityContext.initialize() should restore the previously selected entity
4. Check IndexedDB > Settings table contains 'current_entity_id' key
5. Verify observer pattern: subscribe, trigger change, confirm callback invoked
</verification>

<success_criteria>
- EntityContext.current returns entity object when set
- EntityContext.entityId returns numeric ID
- Setting entity persists to db.settings table
- Page refresh restores entity from settings
- Observer callbacks invoked on entity change
- Errors thrown for deleted/archived/missing entities
</success_criteria>

<output>
After completion, create `.planning/phases/13-multi-entity-architecture/13-02-SUMMARY.md`
</output>

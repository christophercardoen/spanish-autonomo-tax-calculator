---
phase: 15-client-management
plan: 02
type: execute
wave: 2
depends_on: ["15-01"]
files_modified: [autonomo_dashboard.html, supabase/functions/vies-validate/index.ts]
autonomous: true
user_setup:
  - service: supabase-edge-functions
    why: "VIES API has CORS restrictions - requires server-side proxy"
    env_vars: []
    dashboard_config:
      - task: "Deploy vies-validate Edge Function"
        location: "Supabase Dashboard > Edge Functions > Deploy New Function OR use Supabase CLI: supabase functions deploy vies-validate"

must_haves:
  truths:
    - "VIESValidator.validateFormat() works offline for EU VAT format checking"
    - "VIESValidator.validateWithVIES() calls Edge Function when online"
    - "VIES validation gracefully degrades to format-only when offline"
    - "ClientManager.createClient() validates tax ID before saving"
    - "ClientManager.getClients() returns only current entity's non-deleted clients"
    - "ClientManager.archiveClient() soft-deletes with deleted_at timestamp"
  artifacts:
    - path: "autonomo_dashboard.html"
      provides: "VIESValidator module, ClientManager module"
      contains: "VIESValidator"
    - path: "supabase/functions/vies-validate/index.ts"
      provides: "VIES SOAP API proxy for CORS-free validation"
      contains: "checkVatService"
  key_links:
    - from: "VIESValidator.validateWithVIES"
      to: "supabase.functions.invoke('vies-validate')"
      via: "Edge Function call"
      pattern: "functions\\.invoke.*vies-validate"
    - from: "ClientManager.createClient"
      to: "VIESValidator or SpanishTaxIdValidator"
      via: "Tax ID validation before DB insert"
      pattern: "(VIESValidator|SpanishTaxIdValidator)\\.(validate|validateFormat)"
    - from: "ClientManager.createClient"
      to: "db.clients.add"
      via: "Dexie insert after validation"
      pattern: "db\\.clients\\.add"
---

<objective>
Implement VIES Edge Function proxy, VIESValidator module for EU VAT validation, and ClientManager for client CRUD operations.

Purpose: Enables CLIENT-01 (create client), CLIENT-02 (Spanish validation), CLIENT-03 (VIES validation), CLIENT-04 (categorization), CLIENT-05 (B2B/B2C), CLIENT-12 (archive). Core data layer for all client management.
Output: Edge Function code, VIESValidator module, ClientManager module with create/get/update/archive
</objective>

<execution_context>
@/Users/christophercardoen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/christophercardoen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-client-management/15-RESEARCH.md
@.planning/phases/15-client-management/15-01-SUMMARY.md
@.planning/phases/12-data-architecture-foundation/12-01-SUMMARY.md
@.planning/phases/14-authentication-permissions/14-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create VIES Edge Function Proxy</name>
  <files>supabase/functions/vies-validate/index.ts</files>
  <action>
Create Supabase Edge Function that proxies VIES SOAP API requests. This bypasses browser CORS restrictions.

**File:** `supabase/functions/vies-validate/index.ts`

```typescript
// VIES VAT Number Validation Proxy
// Proxies requests to EU VIES SOAP API to bypass CORS restrictions
// Deploy with: supabase functions deploy vies-validate

import { serve } from 'https://deno.land/std@0.177.0/http/server.ts'

const VIES_ENDPOINT = 'https://ec.europa.eu/taxation_customs/vies/services/checkVatService';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'POST, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type, Authorization'
};

serve(async (req) => {
  // Handle CORS preflight
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  if (req.method !== 'POST') {
    return new Response(JSON.stringify({ error: 'Method not allowed' }), {
      status: 405,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });
  }

  try {
    const { countryCode, vatNumber } = await req.json();

    if (!countryCode || !vatNumber) {
      return new Response(JSON.stringify({
        error: 'Missing countryCode or vatNumber'
      }), {
        status: 400,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    // Build SOAP request
    const soapRequest = `<?xml version="1.0" encoding="UTF-8"?>
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
                  xmlns:urn="urn:ec.europa.eu:taxud:vies:services:checkVat:types">
  <soapenv:Body>
    <urn:checkVat>
      <urn:countryCode>${escapeXml(countryCode)}</urn:countryCode>
      <urn:vatNumber>${escapeXml(vatNumber)}</urn:vatNumber>
    </urn:checkVat>
  </soapenv:Body>
</soapenv:Envelope>`;

    const response = await fetch(VIES_ENDPOINT, {
      method: 'POST',
      headers: { 'Content-Type': 'text/xml; charset=utf-8' },
      body: soapRequest
    });

    if (!response.ok) {
      throw new Error(`VIES returned ${response.status}`);
    }

    const xml = await response.text();

    // Parse SOAP response
    const valid = xml.includes('<valid>true</valid>');
    const nameMatch = xml.match(/<name>([^<]*)<\/name>/);
    const addressMatch = xml.match(/<address>([^<]*)<\/address>/);

    // Check for fault (service unavailable, etc.)
    if (xml.includes('INVALID_INPUT')) {
      return new Response(JSON.stringify({
        valid: false,
        error: 'INVALID_INPUT',
        message: 'El formato del NIF-IVA no es válido para este país'
      }), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    if (xml.includes('MS_UNAVAILABLE') || xml.includes('SERVICE_UNAVAILABLE')) {
      return new Response(JSON.stringify({
        valid: null,
        error: 'SERVICE_UNAVAILABLE',
        message: 'Servicio VIES no disponible temporalmente'
      }), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    return new Response(JSON.stringify({
      valid,
      name: nameMatch?.[1]?.trim() || null,
      address: addressMatch?.[1]?.trim() || null,
      requestDate: new Date().toISOString()
    }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });

  } catch (error) {
    console.error('VIES validation error:', error);
    return new Response(JSON.stringify({
      valid: null,
      error: 'PROXY_ERROR',
      message: 'Error al conectar con el servicio VIES'
    }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });
  }
});

// Escape XML special characters to prevent injection
function escapeXml(str: string): string {
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&apos;');
}
```

**Directory structure:** Create `supabase/functions/vies-validate/` directory if it doesn't exist.

**Note:** User must deploy this function to Supabase. Include deployment instructions in SUMMARY.
  </action>
  <verify>
File exists at supabase/functions/vies-validate/index.ts with:
- CORS headers for browser access
- SOAP request construction
- Response parsing for valid/name/address
- Error handling for SERVICE_UNAVAILABLE
- XML escaping for security
  </verify>
  <done>
VIES Edge Function code created. Ready for user to deploy via Supabase CLI or Dashboard.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement VIESValidator Module</name>
  <files>autonomo_dashboard.html</files>
  <action>
Add VIESValidator module after CLIENT_CATEGORY constants. Provides format-only and full VIES validation.

```javascript
// === VIES VAT Validation Module ===
const VIESValidator = {
  /**
   * Format-only validation (offline-safe, always works)
   * @param {string} countryCode - ISO country code (e.g., 'BE')
   * @param {string} vatNumber - VAT number without country prefix
   * @returns {{ valid: boolean, error?: string, formatted?: string }}
   */
  validateFormat(countryCode, vatNumber) {
    if (!countryCode || !vatNumber) {
      return { valid: false, error: 'Código de país y NIF-IVA requeridos' };
    }

    const code = countryCode.toUpperCase();
    const normalized = vatNumber.toUpperCase().replace(/[\s\-\.]/g, '');

    // Map GR to EL for Greece
    const lookupCode = code === 'GR' ? 'EL' : code;

    const pattern = EU_VAT_PATTERNS[lookupCode];
    if (!pattern) {
      return { valid: false, error: 'País no soportado para validación VIES' };
    }

    // Construct full VAT number with country prefix
    const fullVat = lookupCode + normalized;

    if (!pattern.test(fullVat)) {
      return {
        valid: false,
        error: `Formato de NIF-IVA inválido para ${lookupCode}`
      };
    }

    return {
      valid: true,
      formatted: fullVat,
      formatOnly: true
    };
  },

  /**
   * Full VIES validation via Edge Function
   * Falls back to format-only when offline
   * @param {string} countryCode - ISO country code
   * @param {string} vatNumber - VAT number without country prefix
   * @returns {Promise<{ valid: boolean, error?: string, name?: string, address?: string, warning?: string }>}
   */
  async validateWithVIES(countryCode, vatNumber) {
    // First, format validation
    const formatResult = this.validateFormat(countryCode, vatNumber);
    if (!formatResult.valid) {
      return formatResult;
    }

    // Check if Supabase is available
    if (!supabase || AuthManager.isOfflineMode()) {
      return {
        ...formatResult,
        warning: 'Validación VIES no disponible en modo offline. Solo se validó el formato.'
      };
    }

    try {
      // Map GR to EL for VIES API
      const viesCountry = countryCode.toUpperCase() === 'GR' ? 'EL' : countryCode.toUpperCase();
      const viesNumber = vatNumber.toUpperCase().replace(/[\s\-\.]/g, '');

      const { data, error } = await supabase.functions.invoke('vies-validate', {
        body: {
          countryCode: viesCountry,
          vatNumber: viesNumber
        }
      });

      if (error) throw error;

      // Handle service unavailability
      if (data.error === 'SERVICE_UNAVAILABLE') {
        return {
          ...formatResult,
          warning: 'Servicio VIES temporalmente no disponible. Formato verificado.'
        };
      }

      if (data.error) {
        return {
          valid: false,
          error: data.message || 'Error de validación VIES'
        };
      }

      return {
        valid: data.valid,
        formatted: formatResult.formatted,
        name: data.name,
        address: data.address,
        validatedAt: data.requestDate
      };

    } catch (err) {
      console.warn('VIES validation failed:', err);
      return {
        ...formatResult,
        warning: 'No se pudo conectar con VIES. Solo se validó el formato.'
      };
    }
  },

  /**
   * Check if country supports VIES validation
   * @param {string} countryCode - ISO country code
   * @returns {boolean}
   */
  isVIESCountry(countryCode) {
    const code = countryCode?.toUpperCase();
    const lookupCode = code === 'GR' ? 'EL' : code;
    return !!EU_VAT_PATTERNS[lookupCode];
  }
};
```

**Placement:** Add after CLIENT_CATEGORY constants and before any manager modules.
  </action>
  <verify>
In browser console:
- `VIESValidator.validateFormat('BE', '0411905847').valid` returns true
- `VIESValidator.validateFormat('BE', '0411905847').formatted` returns 'BE0411905847'
- `VIESValidator.validateFormat('GR', '123456789').formatted` returns 'EL123456789' (GR mapped to EL)
- `VIESValidator.validateFormat('XX', '123').valid` returns false
- `VIESValidator.isVIESCountry('BE')` returns true
- `VIESValidator.isVIESCountry('US')` returns false
  </verify>
  <done>
VIESValidator module provides format validation (always works) and VIES API validation (requires Edge Function). Greece GR/EL mapping handled transparently.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement ClientManager Module</name>
  <files>autonomo_dashboard.html</files>
  <action>
Add ClientManager module for client CRUD operations. Follows existing patterns from EntityManager.

```javascript
// === Client Manager Module ===
const ClientManager = {
  /**
   * Create a new client
   * Validates tax ID based on country, categorizes automatically
   * @param {Object} clientData - Client data
   * @returns {Promise<number>} - Created client ID
   */
  async createClient(clientData) {
    const entityId = EntityContext.entityId;
    if (!entityId) {
      throw new Error('No hay entidad seleccionada');
    }

    // Normalize input
    const normalized = {
      entity_id: entityId,
      name: clientData.name?.trim(),
      email: clientData.email?.trim() || null,
      phone: clientData.phone?.trim() || null,
      address: clientData.address?.trim() || null,
      country_code: clientData.country_code?.toUpperCase() || 'ES',
      is_b2b: clientData.is_b2b !== false, // Default true for businesses
      w8ben_uploaded: false,
      w8ben_uploaded_at: null
    };

    if (!normalized.name) {
      throw new Error('El nombre del cliente es obligatorio');
    }

    // Tax ID validation based on country
    if (clientData.tax_id) {
      const taxId = clientData.tax_id.trim();

      if (normalized.country_code === 'ES') {
        // Spanish client: use SpanishTaxIdValidator
        const validation = SpanishTaxIdValidator.validate(taxId);
        if (!validation.valid) {
          throw new Error(validation.error);
        }
        normalized.tax_id = validation.normalized;
        normalized.tax_id_type = validation.type.toLowerCase(); // 'nif', 'cif', 'nie'
        normalized.tax_id_validated = true;
        normalized.tax_id_validated_at = new Date().toISOString();
      } else if (VIESValidator.isVIESCountry(normalized.country_code)) {
        // EU client: format validation (VIES checked separately via UI button)
        const formatResult = VIESValidator.validateFormat(normalized.country_code, taxId);
        if (!formatResult.valid) {
          throw new Error(formatResult.error);
        }
        normalized.tax_id = formatResult.formatted;
        normalized.tax_id_type = 'eu_vat';
        normalized.tax_id_validated = false; // Not VIES validated yet
        normalized.tax_id_validated_at = null;
      } else {
        // Third country: store as-is
        normalized.tax_id = taxId.toUpperCase().replace(/[\s\-]/g, '');
        normalized.tax_id_type = 'third_country';
        normalized.tax_id_validated = true; // No external validation needed
        normalized.tax_id_validated_at = new Date().toISOString();
      }
    } else {
      normalized.tax_id = null;
      normalized.tax_id_type = null;
      normalized.tax_id_validated = false;
      normalized.tax_id_validated_at = null;
    }

    // Set category based on country and B2B flag
    normalized.category = getClientCategoryByCountry(normalized.country_code, normalized.is_b2b);

    // Add audit fields
    const client = {
      ...normalized,
      deleted_at: null,
      ...auditFields(true) // created_at, updated_at
    };

    const id = await db.clients.add(client);

    // Queue for sync
    await SyncQueue.queueChange('clients', id, 'CREATE', client);

    return id;
  },

  /**
   * Get all clients for current entity
   * @param {Object} options - Filter options
   * @returns {Promise<Array>}
   */
  async getClients(options = {}) {
    const entityId = EntityContext.entityId;
    if (!entityId) return [];

    let clients = await db.clients
      .where('[entity_id+deleted_at]')
      .equals([entityId, null])
      .toArray();

    // Apply filters
    if (options.search) {
      const term = options.search.toLowerCase();
      clients = clients.filter(c =>
        c.name?.toLowerCase().includes(term) ||
        c.tax_id?.toLowerCase().includes(term) ||
        c.email?.toLowerCase().includes(term)
      );
    }

    if (options.country_code) {
      clients = clients.filter(c => c.country_code === options.country_code);
    }

    if (options.category) {
      clients = clients.filter(c => c.category === options.category);
    }

    // Sort alphabetically by name (per CONTEXT.md)
    clients.sort((a, b) => (a.name || '').localeCompare(b.name || '', 'es'));

    return clients;
  },

  /**
   * Get single client by ID
   * @param {number} clientId
   * @returns {Promise<Object|null>}
   */
  async getClient(clientId) {
    const client = await db.clients.get(clientId);
    if (!client || client.deleted_at) return null;

    // Verify entity access
    if (client.entity_id !== EntityContext.entityId) {
      return null;
    }

    return client;
  },

  /**
   * Update client
   * @param {number} clientId
   * @param {Object} updates
   * @returns {Promise<void>}
   */
  async updateClient(clientId, updates) {
    const client = await this.getClient(clientId);
    if (!client) {
      throw new Error('Cliente no encontrado');
    }

    // If tax_id changed, revalidate
    if (updates.tax_id !== undefined && updates.tax_id !== client.tax_id) {
      const countryCode = updates.country_code || client.country_code;

      if (updates.tax_id) {
        if (countryCode === 'ES') {
          const validation = SpanishTaxIdValidator.validate(updates.tax_id);
          if (!validation.valid) throw new Error(validation.error);
          updates.tax_id = validation.normalized;
          updates.tax_id_type = validation.type.toLowerCase();
          updates.tax_id_validated = true;
          updates.tax_id_validated_at = new Date().toISOString();
        } else if (VIESValidator.isVIESCountry(countryCode)) {
          const formatResult = VIESValidator.validateFormat(countryCode, updates.tax_id);
          if (!formatResult.valid) throw new Error(formatResult.error);
          updates.tax_id = formatResult.formatted;
          updates.tax_id_type = 'eu_vat';
          updates.tax_id_validated = false; // Requires VIES re-validation
          updates.tax_id_validated_at = null;
        }
      }
    }

    // Recalculate category if country or B2B changed
    if (updates.country_code !== undefined || updates.is_b2b !== undefined) {
      const countryCode = updates.country_code || client.country_code;
      const isB2B = updates.is_b2b !== undefined ? updates.is_b2b : client.is_b2b;
      updates.category = getClientCategoryByCountry(countryCode, isB2B);
    }

    // Add update timestamp
    updates.updated_at = new Date().toISOString();

    await db.clients.update(clientId, updates);
    await SyncQueue.queueChange('clients', clientId, 'UPDATE', updates);
  },

  /**
   * Mark VIES validation result on client
   * @param {number} clientId
   * @param {Object} viesResult - Result from VIESValidator.validateWithVIES
   * @returns {Promise<void>}
   */
  async setVIESValidation(clientId, viesResult) {
    await db.clients.update(clientId, {
      tax_id_validated: viesResult.valid === true,
      tax_id_validated_at: viesResult.validatedAt || new Date().toISOString(),
      updated_at: new Date().toISOString()
    });
  },

  /**
   * Archive (soft delete) client
   * @param {number} clientId
   * @returns {Promise<void>}
   */
  async archiveClient(clientId) {
    return DataManager.softDelete('clients', clientId);
  },

  /**
   * Restore archived client
   * @param {number} clientId
   * @returns {Promise<void>}
   */
  async restoreClient(clientId) {
    return DataManager.restore('clients', clientId);
  }
};
```

**Placement:** Add after VIESValidator module.
  </action>
  <verify>
In browser console (after creating an entity):
- `await ClientManager.createClient({ name: 'Test Client', country_code: 'ES', tax_id: '12345678Z' })` returns ID
- `await ClientManager.getClients()` returns array with test client
- `await ClientManager.getClient(1)` returns client object
- `(await ClientManager.getClients({ search: 'Test' })).length` >= 1
- Client in IndexedDB has category 'spain', tax_id normalized, timestamps present
  </verify>
  <done>
ClientManager provides full CRUD for clients with automatic tax ID validation, country categorization, soft delete, and sync queue integration. Spanish clients use SpanishTaxIdValidator; EU clients use VIESValidator format check (VIES API called separately).
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Edge Function:**
   - File exists at supabase/functions/vies-validate/index.ts
   - Contains SOAP request construction
   - Has CORS headers

2. **VIESValidator:**
   - Format validation works offline
   - GR maps to EL
   - Gracefully degrades when Supabase unavailable

3. **ClientManager:**
   - createClient validates Spanish tax IDs via SpanishTaxIdValidator
   - createClient validates EU VAT format via VIESValidator
   - getClients filters by entity_id
   - archiveClient uses soft delete
   - Updates trigger sync queue

4. **Integration:**
   - No console errors on page load
   - EntityContext.entityId required for all operations
</verification>

<success_criteria>
- VIES Edge Function code exists in supabase/functions/vies-validate/
- VIESValidator.validateFormat() works for all EU countries
- VIESValidator.validateWithVIES() falls back gracefully when offline
- ClientManager.createClient() validates and normalizes tax IDs
- ClientManager.createClient() sets category based on country
- ClientManager.getClients() returns only current entity's clients
- ClientManager.archiveClient() soft-deletes with deleted_at
- All changes queued to SyncQueue
- No JavaScript console errors
</success_criteria>

<output>
After completion, create `.planning/phases/15-client-management/15-02-SUMMARY.md`

Include user setup note: VIES Edge Function must be deployed to Supabase before EU VAT validation will work online.
</output>

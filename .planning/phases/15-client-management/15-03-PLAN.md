---
phase: 15-client-management
plan: 03
type: execute
wave: 2
depends_on: ["15-02"]
files_modified: [autonomo_dashboard.html]
autonomous: true

must_haves:
  truths:
    - "User can add multiple contacts per client with roles (billing, project_manager, technical, general)"
    - "User can mark one contact as primary per client"
    - "User can create projects with daily, hourly, fixed, or monthly_retainer rate types"
    - "Project status auto-calculates based on start/end dates (upcoming, active, completed)"
    - "Project status can be manually overridden (e.g., cancelled)"
  artifacts:
    - path: "autonomo_dashboard.html"
      provides: "ContactManager module, ProjectManager module, RATE_TYPE and PROJECT_STATUS constants"
      contains: "ContactManager"
  key_links:
    - from: "ContactManager.createContact"
      to: "db.contacts.add"
      via: "Dexie insert"
      pattern: "db\\.contacts\\.add"
    - from: "ProjectManager.createProject"
      to: "db.projects.add"
      via: "Dexie insert"
      pattern: "db\\.projects\\.add"
    - from: "ProjectManager.getStatus"
      to: "date comparison logic"
      via: "Auto-calculate from start_date/end_date"
      pattern: "start_date.*end_date"
---

<objective>
Implement ContactManager for multiple contacts per client and ProjectManager for project CRUD with rate types and auto-status calculation.

Purpose: Enables CLIENT-07 (multiple contacts), CLIENT-08 (projects with rate/dates), CLIENT-09 (work patterns - basic foundation). Projects are the billable units that connect to calendar days and invoices in later phases.
Output: ContactManager module, ProjectManager module, RATE_TYPE and PROJECT_STATUS constants
</objective>

<execution_context>
@/Users/christophercardoen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/christophercardoen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-client-management/15-CONTEXT.md
@.planning/phases/15-client-management/15-RESEARCH.md
@.planning/phases/15-client-management/15-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement ContactManager Module</name>
  <files>autonomo_dashboard.html</files>
  <action>
Add CONTACT_ROLE constants and ContactManager module after ClientManager.

**Constants:**

```javascript
// === Contact Role Constants ===
const CONTACT_ROLE = Object.freeze({
  BILLING: 'billing',
  PROJECT_MANAGER: 'project_manager',
  TECHNICAL: 'technical',
  GENERAL: 'general'
});

const CONTACT_ROLE_LABELS = Object.freeze({
  [CONTACT_ROLE.BILLING]: 'Facturación',
  [CONTACT_ROLE.PROJECT_MANAGER]: 'Gestor de proyecto',
  [CONTACT_ROLE.TECHNICAL]: 'Técnico',
  [CONTACT_ROLE.GENERAL]: 'General'
});
```

**ContactManager:**

```javascript
// === Contact Manager Module ===
const ContactManager = {
  /**
   * Create a contact for a client
   * @param {number} clientId
   * @param {Object} contactData
   * @returns {Promise<number>} - Created contact ID
   */
  async createContact(clientId, contactData) {
    // Verify client exists and belongs to current entity
    const client = await ClientManager.getClient(clientId);
    if (!client) {
      throw new Error('Cliente no encontrado');
    }

    const normalized = {
      client_id: clientId,
      name: contactData.name?.trim(),
      email: contactData.email?.trim() || null,
      phone: contactData.phone?.trim() || null,
      role: contactData.role || CONTACT_ROLE.GENERAL,
      is_primary: !!contactData.is_primary,
      ...auditFields(true)
    };

    if (!normalized.name) {
      throw new Error('El nombre del contacto es obligatorio');
    }

    // If marking as primary, unset other primaries for this client
    if (normalized.is_primary) {
      await this._clearPrimaryContact(clientId);
    }

    const id = await db.contacts.add(normalized);
    await SyncQueue.queueChange('contacts', id, 'CREATE', normalized);

    return id;
  },

  /**
   * Get all contacts for a client
   * @param {number} clientId
   * @returns {Promise<Array>}
   */
  async getContacts(clientId) {
    const contacts = await db.contacts
      .where('client_id')
      .equals(clientId)
      .toArray();

    // Sort: primary first, then by name
    contacts.sort((a, b) => {
      if (a.is_primary && !b.is_primary) return -1;
      if (!a.is_primary && b.is_primary) return 1;
      return (a.name || '').localeCompare(b.name || '', 'es');
    });

    return contacts;
  },

  /**
   * Get primary contact for a client
   * @param {number} clientId
   * @returns {Promise<Object|null>}
   */
  async getPrimaryContact(clientId) {
    const contacts = await this.getContacts(clientId);
    return contacts.find(c => c.is_primary) || contacts[0] || null;
  },

  /**
   * Update a contact
   * @param {number} contactId
   * @param {Object} updates
   * @returns {Promise<void>}
   */
  async updateContact(contactId, updates) {
    const contact = await db.contacts.get(contactId);
    if (!contact) {
      throw new Error('Contacto no encontrado');
    }

    // Verify client access
    const client = await ClientManager.getClient(contact.client_id);
    if (!client) {
      throw new Error('Acceso denegado');
    }

    // If marking as primary, unset other primaries
    if (updates.is_primary && !contact.is_primary) {
      await this._clearPrimaryContact(contact.client_id);
    }

    updates.updated_at = new Date().toISOString();

    await db.contacts.update(contactId, updates);
    await SyncQueue.queueChange('contacts', contactId, 'UPDATE', updates);
  },

  /**
   * Delete a contact
   * @param {number} contactId
   * @returns {Promise<void>}
   */
  async deleteContact(contactId) {
    const contact = await db.contacts.get(contactId);
    if (!contact) return;

    // Verify client access
    const client = await ClientManager.getClient(contact.client_id);
    if (!client) {
      throw new Error('Acceso denegado');
    }

    await db.contacts.delete(contactId);
    await SyncQueue.queueChange('contacts', contactId, 'DELETE', null);
  },

  /**
   * Set a contact as primary (unsets others)
   * @param {number} contactId
   * @returns {Promise<void>}
   */
  async setPrimaryContact(contactId) {
    await this.updateContact(contactId, { is_primary: true });
  },

  /**
   * Clear primary flag from all contacts for a client
   * @private
   */
  async _clearPrimaryContact(clientId) {
    const contacts = await db.contacts
      .where('client_id')
      .equals(clientId)
      .filter(c => c.is_primary)
      .toArray();

    for (const contact of contacts) {
      await db.contacts.update(contact.id, {
        is_primary: false,
        updated_at: new Date().toISOString()
      });
    }
  }
};
```

**Placement:** Add after ClientManager module.
  </action>
  <verify>
In browser console (with entity selected and client created):
- `await ContactManager.createContact(1, { name: 'Jan Janssen', email: 'jan@test.be', role: 'billing', is_primary: true })` returns ID
- `await ContactManager.getContacts(1)` returns array with contact
- `await ContactManager.getPrimaryContact(1)` returns Jan's contact
- `CONTACT_ROLE_LABELS.billing` returns 'Facturación'
  </verify>
  <done>
ContactManager enables multiple contacts per client with roles and primary designation. Primary contact auto-unsets others when set.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement ProjectManager Module</name>
  <files>autonomo_dashboard.html</files>
  <action>
Add RATE_TYPE, PROJECT_STATUS constants and ProjectManager module after ContactManager.

**Constants:**

```javascript
// === Project Constants ===
const RATE_TYPE = Object.freeze({
  DAILY: 'daily',
  HOURLY: 'hourly',
  FIXED: 'fixed',
  MONTHLY_RETAINER: 'monthly_retainer'
});

const RATE_TYPE_LABELS = Object.freeze({
  [RATE_TYPE.DAILY]: 'Diario',
  [RATE_TYPE.HOURLY]: 'Por hora',
  [RATE_TYPE.FIXED]: 'Precio fijo',
  [RATE_TYPE.MONTHLY_RETAINER]: 'Retainer mensual'
});

const PROJECT_STATUS = Object.freeze({
  UPCOMING: 'upcoming',
  ACTIVE: 'active',
  COMPLETED: 'completed',
  CANCELLED: 'cancelled'
});

const PROJECT_STATUS_LABELS = Object.freeze({
  [PROJECT_STATUS.UPCOMING]: 'Próximo',
  [PROJECT_STATUS.ACTIVE]: 'Activo',
  [PROJECT_STATUS.COMPLETED]: 'Completado',
  [PROJECT_STATUS.CANCELLED]: 'Cancelado'
});
```

**ProjectManager:**

```javascript
// === Project Manager Module ===
const ProjectManager = {
  /**
   * Create a project for a client
   * @param {number} clientId
   * @param {Object} projectData
   * @returns {Promise<number>} - Created project ID
   */
  async createProject(clientId, projectData) {
    // Verify client exists
    const client = await ClientManager.getClient(clientId);
    if (!client) {
      throw new Error('Cliente no encontrado');
    }

    const entityId = EntityContext.entityId;

    const normalized = {
      client_id: clientId,
      entity_id: entityId, // Denormalized for faster queries
      name: projectData.name?.trim(),
      rate_type: projectData.rate_type || RATE_TYPE.DAILY,
      rate_cents: projectData.rate_cents || 0,
      start_date: projectData.start_date || null,
      end_date: projectData.end_date || null,
      status_override: projectData.status_override || null,
      notes: projectData.notes?.trim() || null,
      deleted_at: null,
      ...auditFields(true)
    };

    if (!normalized.name) {
      throw new Error('El nombre del proyecto es obligatorio');
    }

    // Validate rate_type
    if (!Object.values(RATE_TYPE).includes(normalized.rate_type)) {
      throw new Error('Tipo de tarifa inválido');
    }

    // Validate dates
    if (normalized.start_date && normalized.end_date) {
      if (normalized.end_date < normalized.start_date) {
        throw new Error('La fecha de fin no puede ser anterior a la fecha de inicio');
      }
    }

    const id = await db.projects.add(normalized);
    await SyncQueue.queueChange('projects', id, 'CREATE', normalized);

    return id;
  },

  /**
   * Get all projects for a client
   * @param {number} clientId
   * @param {Object} options
   * @returns {Promise<Array>}
   */
  async getProjectsByClient(clientId, options = {}) {
    let projects = await db.projects
      .where('[client_id+deleted_at]')
      .equals([clientId, null])
      .toArray();

    // Calculate status for each project
    projects = projects.map(p => ({
      ...p,
      status: this.calculateStatus(p)
    }));

    // Filter by status if specified
    if (options.status) {
      projects = projects.filter(p => p.status === options.status);
    }

    // Sort by start date (most recent first)
    projects.sort((a, b) => {
      if (!a.start_date) return 1;
      if (!b.start_date) return -1;
      return b.start_date.localeCompare(a.start_date);
    });

    return projects;
  },

  /**
   * Get all projects for current entity
   * @param {Object} options
   * @returns {Promise<Array>}
   */
  async getProjects(options = {}) {
    const entityId = EntityContext.entityId;
    if (!entityId) return [];

    let projects = await db.projects
      .where('[entity_id+deleted_at]')
      .equals([entityId, null])
      .toArray();

    // Calculate status for each
    projects = projects.map(p => ({
      ...p,
      status: this.calculateStatus(p)
    }));

    // Filter by status if specified
    if (options.status) {
      projects = projects.filter(p => p.status === options.status);
    }

    return projects;
  },

  /**
   * Get active projects for a client (for display)
   * @param {number} clientId
   * @returns {Promise<Array>}
   */
  async getActiveProjects(clientId) {
    return this.getProjectsByClient(clientId, { status: PROJECT_STATUS.ACTIVE });
  },

  /**
   * Get single project by ID
   * @param {number} projectId
   * @returns {Promise<Object|null>}
   */
  async getProject(projectId) {
    const project = await db.projects.get(projectId);
    if (!project || project.deleted_at) return null;

    // Verify entity access
    if (project.entity_id !== EntityContext.entityId) {
      return null;
    }

    return {
      ...project,
      status: this.calculateStatus(project)
    };
  },

  /**
   * Update a project
   * @param {number} projectId
   * @param {Object} updates
   * @returns {Promise<void>}
   */
  async updateProject(projectId, updates) {
    const project = await this.getProject(projectId);
    if (!project) {
      throw new Error('Proyecto no encontrado');
    }

    // Validate dates if both are being set
    const startDate = updates.start_date !== undefined ? updates.start_date : project.start_date;
    const endDate = updates.end_date !== undefined ? updates.end_date : project.end_date;

    if (startDate && endDate && endDate < startDate) {
      throw new Error('La fecha de fin no puede ser anterior a la fecha de inicio');
    }

    updates.updated_at = new Date().toISOString();

    await db.projects.update(projectId, updates);
    await SyncQueue.queueChange('projects', projectId, 'UPDATE', updates);
  },

  /**
   * Archive (soft delete) project
   * @param {number} projectId
   * @returns {Promise<void>}
   */
  async archiveProject(projectId) {
    return DataManager.softDelete('projects', projectId);
  },

  /**
   * Calculate project status based on dates
   * @param {Object} project
   * @returns {string}
   */
  calculateStatus(project) {
    // Manual override takes precedence
    if (project.status_override) {
      return project.status_override;
    }

    const today = new Date().toISOString().split('T')[0];

    // No start date = upcoming
    if (!project.start_date) {
      return PROJECT_STATUS.UPCOMING;
    }

    // Start date in future = upcoming
    if (project.start_date > today) {
      return PROJECT_STATUS.UPCOMING;
    }

    // No end date or end date in future = active
    if (!project.end_date || project.end_date >= today) {
      return PROJECT_STATUS.ACTIVE;
    }

    // End date in past = completed
    return PROJECT_STATUS.COMPLETED;
  },

  /**
   * Format rate for display
   * @param {Object} project
   * @returns {string}
   */
  formatRate(project) {
    const amount = MoneyUtils.formatEuros(project.rate_cents);
    const suffix = {
      [RATE_TYPE.DAILY]: '/día',
      [RATE_TYPE.HOURLY]: '/hora',
      [RATE_TYPE.FIXED]: ' (fijo)',
      [RATE_TYPE.MONTHLY_RETAINER]: '/mes'
    }[project.rate_type] || '';

    return amount + suffix;
  },

  /**
   * Count active projects for a client (for list display)
   * @param {number} clientId
   * @returns {Promise<number>}
   */
  async countActiveProjects(clientId) {
    const projects = await this.getActiveProjects(clientId);
    return projects.length;
  }
};
```

**Placement:** Add after ContactManager module.
  </action>
  <verify>
In browser console (with entity and client):
- `await ProjectManager.createProject(1, { name: 'IT Consulting Q1', rate_type: 'daily', rate_cents: 65000, start_date: '2026-02-01' })` returns ID
- `await ProjectManager.getProjectsByClient(1)` returns array with project
- `await ProjectManager.getProject(1)` returns project with calculated status
- `ProjectManager.calculateStatus({ start_date: '2025-01-01', end_date: '2025-12-31' })` returns 'completed'
- `ProjectManager.calculateStatus({ start_date: '2026-06-01' })` returns 'upcoming'
- `ProjectManager.calculateStatus({ start_date: '2026-01-01', status_override: 'cancelled' })` returns 'cancelled'
- `ProjectManager.formatRate({ rate_cents: 65000, rate_type: 'daily' })` includes '/día'
  </verify>
  <done>
ProjectManager enables project CRUD with 4 rate types, auto-calculated status from dates, and manual status override. Rate formatting helper for UI display.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **ContactManager:**
   - CRUD operations work
   - Primary contact designation works
   - Contacts belong to clients

2. **ProjectManager:**
   - CRUD operations work
   - Status auto-calculates correctly
   - Manual override takes precedence
   - Rate formatting works
   - Projects entity-scoped

3. **Integration:**
   - No console errors
   - SyncQueue receives changes
   - Proper error messages in Spanish
</verification>

<success_criteria>
- ContactManager.createContact() creates contact with role
- ContactManager.getPrimaryContact() returns primary or first contact
- ContactManager.setPrimaryContact() unsets other primaries
- ProjectManager.createProject() validates rate_type and dates
- ProjectManager.calculateStatus() returns correct status based on dates
- ProjectManager.calculateStatus() respects status_override
- ProjectManager.formatRate() includes rate type suffix
- All changes queued to SyncQueue
- Error messages in Spanish
</success_criteria>

<output>
After completion, create `.planning/phases/15-client-management/15-03-SUMMARY.md`
</output>

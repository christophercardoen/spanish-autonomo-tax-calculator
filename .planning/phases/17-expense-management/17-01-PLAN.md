---
phase: 17-expense-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: ["autonomo_dashboard.html"]
autonomous: true

must_haves:
  truths:
    - "EXPENSE_CATEGORY frozen object defines all 10 expense categories with per-entity-type deduction rules"
    - "ExpenseManager can create, read, update, and soft-delete expenses in IndexedDB"
    - "calculateDeductible returns correct deductible_amount_cents based on category rules and entity type"
    - "All monetary values stored as integer cents via MoneyUtils"
  artifacts:
    - path: "autonomo_dashboard.html"
      provides: "EXPENSE_CATEGORY config, ExpenseManager singleton"
      contains: "const EXPENSE_CATEGORY, const ExpenseManager"
  key_links:
    - from: "ExpenseManager"
      to: "db.expenses"
      via: "Dexie CRUD operations"
      pattern: "db\\.expenses\\.(add|where|update|get)"
    - from: "ExpenseManager"
      to: "EXPENSE_CATEGORY"
      via: "calculateDeductible lookup"
      pattern: "EXPENSE_CATEGORY\\[.*\\]\\.rules"
    - from: "ExpenseManager"
      to: "EntityContext"
      via: "entity scoping"
      pattern: "EntityContext\\.entityId"
    - from: "ExpenseManager"
      to: "SyncQueue"
      via: "offline sync"
      pattern: "SyncQueue\\.queueChange"
---

<objective>
Create the EXPENSE_CATEGORY configuration object and ExpenseManager singleton that form the data layer for Phase 17 expense tracking.

Purpose: Establish the complete business logic layer for expenses with entity-type-aware (Autonomo vs SL) deduction rules, following the established ProjectManager pattern.
Output: Two new JavaScript objects (EXPENSE_CATEGORY, ExpenseManager) added to autonomo_dashboard.html with full CRUD operations.
</objective>

<execution_context>
@/Users/christophercardoen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/christophercardoen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-expense-management/17-RESEARCH.md
@autonomo_dashboard.html (lines 17472-17475 for ENTITY_TYPE, 18447-18560 for ProjectManager pattern, 16747-16806 for MoneyUtils, 16812-16828 for auditFields, 16840-16910 for SyncQueue, 17028-17140 for DataManager, 19680-19778 for EntityContext, 13427-13430 for expenses/receipts schema)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EXPENSE_CATEGORY frozen configuration object</name>
  <files>autonomo_dashboard.html</files>
  <action>
Add the EXPENSE_CATEGORY constant immediately after the ENTITY_TYPE constant (around line 17475). This frozen object defines all expense categories with entity-type-aware deduction rules.

Create exactly these 10 categories with the structure shown below. Each category has: key, label, optional subcategories array, optional sl_only boolean, and a rules object keyed by ENTITY_TYPE values ('autonomo' and 'sociedad_limitada').

Categories:
1. HOME_OFFICE: proportional 30% max for autonomo, full_if_justified for SL
2. GSM: 50% default for autonomo, 100% for SL
3. VEHICLE: 0% IRPF default for autonomo (50% IVA), 100% for SL
4. MEALS_DIETAS: dietas_limit method for autonomo (with spain/abroad + overnight limits in cents: 2667/5334/4808/9135), full_if_justified for SL
5. TRAVEL: full_if_justified both, with mileage_rate_cents: 26
6. IT_SOFTWARE: full 100% both, depreciation group 5
7. OFFICE_SUPPLIES: full 100% both
8. PROFESSIONAL_SERVICES: full 100% both (gestor, lawyer)
9. TRAINING: full 100% both
10. DEPRECIATION: sl_only: true, amortization_table for SL, note-only for autonomo

Use Object.freeze() on the top-level object. Reference the ENTITY_TYPE constants for rule keys (not string literals).

IMPORTANT: Do NOT include "gastos dificil justificacion" as a category. It is an automatic IRPF deduction already handled in the tax calculation engine, NOT a user-entered expense.

Follow the exact structure from the research file (17-RESEARCH.md Pattern 1).
  </action>
  <verify>Search for "EXPENSE_CATEGORY" in the file - should find the frozen object with all 10 categories. Verify ENTITY_TYPE.AUTONOMO and ENTITY_TYPE.SOCIEDAD_LIMITADA are used as rule keys.</verify>
  <done>EXPENSE_CATEGORY frozen object exists with 10 categories, each having entity-type-specific deduction rules. HOME_OFFICE has max_proportion 0.30, MEALS_DIETAS has 4 limit values in cents, VEHICLE has 0% autonomo default.</done>
</task>

<task type="auto">
  <name>Task 2: Create ExpenseManager singleton with CRUD and deduction calculation</name>
  <files>autonomo_dashboard.html</files>
  <action>
Add the ExpenseManager singleton after the ProjectManager (around line 18690, after ProjectManager ends). Follow the exact same pattern as ProjectManager but with expense-specific fields and deduction logic.

ExpenseManager must have these methods:

1. **createExpense(expenseData)** - Creates expense in db.expenses
   - Gets entityId from EntityContext.entityId (throw if missing)
   - Gets entity type from EntityContext.current.type
   - Calls calculateDeductible() to compute deductible_amount_cents
   - Normalizes fields: entity_id, category, subcategory, vendor, date (YYYY-MM-DD), amount_cents, iva_cents, deductible_amount_cents, description, is_billable, client_id, project_id, receipt_id, destination, trip_start_date, trip_end_date, has_overnight, payment_method, deleted_at: null, ...auditFields(true)
   - Validates: amount_cents > 0, category is valid EXPENSE_CATEGORY key, date is present
   - Adds to db.expenses, queues via SyncQueue.queueChange('expenses', id, 'CREATE', normalized)
   - Returns created ID

2. **getExpenses(options = {})** - Get all expenses for current entity
   - Filters by EntityContext.entityId, deleted_at === null
   - Supports options: category, client_id, project_id, date_from, date_to, is_billable
   - Sorts by date descending (most recent first)
   - Returns array

3. **getExpense(id)** - Get single expense by ID
   - Verifies entity_id matches EntityContext.entityId
   - Returns expense or null

4. **updateExpense(id, changes)** - Update expense fields
   - Recalculates deductible_amount_cents if amount or category changed
   - Adds auditFields(false)
   - Queues SyncQueue UPDATE
   - Returns updated record

5. **archiveExpense(id)** - Soft delete via DataManager.softDelete('expenses', id)
   - EXPENSE-15: Check if expense has linked receipt (receipt_id). If yes, soft delete only (don't prevent deletion, but use soft delete which is already the behavior)
   - Returns boolean

6. **calculateDeductible(amountCents, category, entityType, metadata = {})** - Core deduction logic
   - Looks up rules from EXPENSE_CATEGORY[category].rules[entityType]
   - Switch on deduction_method:
     - 'full': return amountCents
     - 'percentage': return MoneyUtils.roundCents(amountCents * rules.default_percentage / 100)
     - 'proportional': return MoneyUtils.roundCents(amountCents * (metadata.business_proportion || rules.max_proportion) * rules.max_proportion)
     - 'dietas_limit': call calculateDietasDeductible()
     - 'full_if_justified': return amountCents
     - default: return amountCents

7. **calculateDietasDeductible(amountCents, rules, metadata)** - Dietas limit logic
   - isAbroad = metadata.destination && metadata.destination !== 'ES'
   - hasOvernight = metadata.has_overnight
   - Select limit from rules.limits based on abroad/overnight combo
   - Return Math.min(amountCents, limitCents)

8. **getExpensesByDate(dateKey)** - Get expenses for a specific date (for calendar linking)
   - Uses [entity_id+date] compound index
   - Returns array of expenses for that date

9. **getExpenseSummary(options = {})** - Get totals for reporting
   - Sums amount_cents, deductible_amount_cents for filtered expenses
   - Groups by category if requested
   - Returns { total_cents, deductible_cents, by_category: { ... } }

All methods must start with `const entityId = EntityContext.entityId; if (!entityId) ...` pattern.
  </action>
  <verify>Search for "const ExpenseManager" in the file. Verify it has createExpense, getExpenses, getExpense, updateExpense, archiveExpense, calculateDeductible, calculateDietasDeductible, getExpensesByDate, getExpenseSummary methods. Check that EntityContext.entityId is used in every query method.</verify>
  <done>ExpenseManager singleton exists with 9 methods. createExpense stores all required fields and calculates deductible. calculateDeductible handles 5 deduction methods. calculateDietasDeductible uses correct AEAT limits (2667/5334/4808/9135 cents). Entity scoping applied to all queries. SyncQueue integration on all mutations.</done>
</task>

</tasks>

<verification>
1. EXPENSE_CATEGORY has exactly 10 categories (HOME_OFFICE through DEPRECIATION)
2. No "gastos_dificil" category exists (it's an IRPF automatic deduction, not an expense)
3. ExpenseManager follows ProjectManager pattern (entity scoping, soft delete, audit fields, sync queue)
4. calculateDeductible returns correct values for each deduction_method
5. MEALS_DIETAS limits match AEAT: Spain 26.67/53.34, Abroad 48.08/91.35 (stored as cents: 2667/5334/4808/9135)
6. All monetary operations use MoneyUtils (eurosToCents, roundCents)
7. Page loads without JavaScript console errors
</verification>

<success_criteria>
- EXPENSE_CATEGORY frozen object with 10 categories and entity-type-aware rules
- ExpenseManager with full CRUD (create, read, update, archive)
- Deduction calculation handles: full, percentage, proportional, dietas_limit, full_if_justified
- Entity scoping on all operations via EntityContext
- SyncQueue integration on all mutations
- Zero console errors on page load
</success_criteria>

<output>
After completion, create `.planning/phases/17-expense-management/17-01-SUMMARY.md`
</output>
